## 23

### 正则

#### 操作符

##### 开头 ^
```js
/^130/
// 匹配开头为130的
```

##### 结尾 $

```js
/130$/
// 匹配结尾为130的
```



##### 或 |
```js
/a|b/
// 匹配含有a或b的
```



###### 结合^ $应用

```js
/^a|b$/ ==>  /^a$/ + /^b$/
// 匹配只有a或者只有b的
```



##### 集合 []

```js
/[abc]/
// 匹配a/b/c

/[0-9a-z]/
// 匹配 0~9和a~z
```



###### 集合下的 ^

```js
/[^0-3]/
// 匹配不是0~3的
```



##### 范围 {}

```js
/^130\d{2,5}$/

// 130开头，至少2个，至多5个 \d

// {2,}  至少两个

// {2} 只有2个

// - ==> {1,}   * ==> {0,}   ? ==> {0,1}
```



###### 任意一个字符 .

```js
/^130........$/

// 匹配130开头的11位字符串

// . ==> {1} ???
```



###### 至少一个字符 +

```js
/^130\d+$/

// 130开头且后面至少有一个 \d 即数字

// + ==> {1,} 


```

###### 任意个字符 *

```js
/^130\d*/
//  130开头,后面可以有任意个 \d 即数字

// * ==> {0,}
```



###### 最多一个 ?

```js
/^130\d?/

// 130开始后面最多跟一个\d

// ? ==> {0,1}
```



##### 分组 ()
将内容作为整体进行匹配

```js
/^(Ho){3}~$/ 

// 匹配 HoHoHo~

/^性别：(男|女)，角色：(管理员|游客)$/

// 匹配 性别：男，角色：管理员、性别：男，角色：游客、性别：女，角色：管理员 或 性别：女，角色：游客。
```



###### 引用
将分组的结果重复使用，分组自动从1开始进行编号

```js
/^['"]\w+['"]$/

// 匹配 "a"、'b'、'c"、"d'

/^(['"])\w+\1$/

// 匹配 "a"、'b'， (['"])分组匹配出 ' / ", 通过\1重复使用它的匹配结果
```



#### 字符
实际根据引擎实现有所不同

##### 任意数字 \d

```js
/^130\d\d\d\d\d\d\d\d$/

// 匹配130开始的11为数字
```



##### 单词字符 \w
大写 + 小写 + 0~9 + _



##### 空白符 \s
空格 + 制表符(\t) + 换行符(\n) + 换页符(\f)



## 27

### 文章

[从原型进行深入拓展探讨](https://zhuanlan.zhihu.com/p/87667349?utm_source=qq&utm_medium=social&utm_oi=583565170786308096)
> 要展开 JS 原型的复杂背景，我们需要将镜头拉远，看到不同编程语言和编程范式下，如何组织数据和行为。从这种宏观的，对比的角度中，了解 prototype 看待数据和行为的方式、其优势和劣势在哪里。如此得到更全面的理解
> 原型 === 部分功能的链表
>
> 
>
> #### 重点
>
> 在规范里，prototype 被定义为：给其它对象提供共享属性的对象。
>
> 
>
> ##### react-hooks
>
> 对象这个概念的瓦解——数据、行为及其关联是三个维度，它们不应被捆绑在对象中。
>
> 数据可以单独声明（useState），行为也可以单独声明（useEffect），数据和行为可以进行可选的关联（custom-hooks）
>



## 30

### 术语



TTFB
> Time to   first byte 
>
> 浏览器开始收到服务器响应数据的时间



### API



requestIdleCallback

> 浏览器繁忙的时候，可能不会有盈余时间，这时候requestIdleCallback回调可能就不会被执行

requestanimacallback





## 网络

3次握手，确认双方的收发功能都正常

