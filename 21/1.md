## 1

### JS

#### toJson

stringify会调用对象toJson方法

```js
const json = JSON.stringify({
  answer: { toJSON: () => 42 }
});

console.log(json); // {"answer":42}

```
## 2

### 切图

#### 手动

**利用辅助线全量切**

1、设计工具中利用辅助线对原型元素进行划分
2、裁剪-->切片工具，切片工具可进行手动框选或直接以辅助器裁剪进行切图
3、导出（建议png格式，图片格式区别）
4、导出时可以选择导出的切图类型（全量，选中...）

**手动框选**

1、裁剪-->切片工具，切片工具可进行手动框选或直接以辅助器裁剪进行切图
2、导出（建议png格式，图片格式区别）
3、导出时可以选择导出的切图类型（全量，选中...）

**安全区域**

1、以图标、安全区域等元素，图层编组
2、转化为智能对象,删除无用图层
3、导出另存（PNG）

#### 工具

**PS**

1、设计软件设计高保真原型，上传蓝湖前标注图标等元素
2、上传蓝湖
3、蓝湖中可直接根据标注下载切图

**sketch**

1、设计时即标记
2、上传蓝湖
3、蓝湖中可直接根据标注下载切图

### 登录设计

- 只要求填写创建帐户所需的基本信息
    - 如果你的注册表单超过两页，你会引起大量的用户跳出
- 对必填、可选内容进行标记，位置按分类放置
- 密码规则明确指出，仅禁用常用密码
- 校验失败时进行内敛提升
    - 在等待事件在元素即将失去焦点时触发
    - 验证字段
    - 如果有错误，指出错误，但不要将注意力集中在该字段上。（填写表格时，不要中断用户流程）
    - 当用户将焦点放在错误字段上（并且该字段不为空）时，检查每个键盘输入事件。如果该字段正确，则将字段变为绿色（但不要在输入框中四处移动，同时会显示一条提示该输入框会移动的消息）。
- 禁止未经验证的电子邮件帐户的访问
    - 除非是业务需求，否则不要因为用户没有点击你发送的链接就阻止他们访问自己的账户
- 重复注册时提示已注册，且提供解决方案（提示跳转登录页...）
- 支持通过社交产品登录
    - 适当选用支持的社交账号
    - 根据流行性进行支持和放置优先级
- 支持tab切换输入
- 支持邮箱登录
- 注册成功后发送欢迎邮件
- 重置密码时应尽量把已有信息附带，不需要用户重复输入
- 多次密码错误后，提供密码重置按钮
- 用户通过链接自行重置而不是生成随机密码
- 支持密码管理器捕获账号密码
- 移动设备登录，支持用户使用其他设备上的身份验证登录
- 支持SSO?
- 对于包含敏感信息/支付信息的要进行两步认证
    - 电子邮件+电话
    - 电子邮件+电子邮件
    - 电子邮件+推送通知
- 如果不是敏感信息类应用，应该长期保持登录状态


这样可以避免验证过程中的任何麻烦

## 3

### C#

#### 泛型

**泛型缓存**

利用静态构造函数进行缓存只执行一次，线程安全?
> 实例化或查找实现接口类，可能由于dll懒加载,导致遗漏

#### 字典

字典key超过1w，性能会快速降低？

#### 反射

##### 实例化反射

类型强转，一定程度上保持类型安全

##### MethodInfo

可跳过强转(不依赖于类型)只依赖于方法名和参数,即可操作

##### PropertyInfo

只依赖于属性名

##### 性能优化

- 缓存
- dynamic
- 基于委托
- emit

#### MVC

通过反射实例化controller，通过MethodInfo调用接口，参数从url/form中读取匹配

**接口重载识别**

接口重载时，如果参数类型一致，无法识别区分调用哪个方法，所以需要提供HttpeGet、HttpPost等标识来协助判断

#### 多线程

##### .Net 1.0、1.1

**Thread**

- 灵活：提供丰富、底层的api
- 安全、管控差：没有管控，可以随意产生无数的线程
- 响应差异：本质会去操作计算机系统底层api，是由计算机系统进行控制的，实际响应和预想间存在一定差异

##### .Net 2.0

**ThreadPool**
进行池化管理，避免频繁的申请和销毁，且自动进行池内资源管理（扩容、销毁），但提供API太少，线程顺序控制能力弱

- 线程复用
- 管控最大线程数量

##### .Net 3.0

**Task**

- 底层利用线程池
- 包含丰富API

Task.WaitAll(TaskList): 阻塞主线程等待所有Task完成
TaskFactory.ContinueWhenAll: 不阻塞主线程，但一堆Task完成后执行


**Parallel**

进行多线程操作，同时主线程也作为其中一个进行执行，不必浪费主线程等待时间，可以通过Options控制并发数量

##### 线程安全

多线程同修改一个对象时容易出现问题
> 多线程对List进行add，可能会产生数据丢失，多个线程同时往同一个内存存数据，导致覆盖丢失

##### 锁

**lock**
语法糖，{}内的代码操作，任意时刻只会由一个线程操作，多的进行排队
```c#
lock(object) { }
```
Lock对象一般建议是private、static、readonly的，唯一且防止被其他因素影响（看实际情况）
原理：锁定对象内存引用地址，占用前后进行标记，阻止其他线程占用

注1：字符串的内存引用可能共用，所以导致锁字符串时会出现问题
注2：泛型对同一个类型的泛型只会产生一个内存类，可能存在共用锁

##### Async/Await

同一个函数中的多个await，每次遇到新的await，所有剩余的代码都会交给新的线程进行处理  

#### 协变和逆变

只能在接口和委托上使用

##### 协变

out根据类型参数作用，等式左边泛型参数是右边泛型参数的父类，即可赋值
out修饰后，泛型类型只能作为返回值类型

```C#
// Child继承Parent
List<Parent> ps = new List<Child>() // 不可，List<Parent>和 List<Child>不是继承关系

IEnumerable<Parent> ips = new List<Child>() // 可

ips.Select((i) => i);  // 被使用时i会是Parent,实质会拿ps的元素当作Parent类型使用，符合子类 --> 父类
// 只能作为结果值被使用，使用时会将原来的子类转化为父类使用
```

##### 逆变

in根据类型参数作用，等式左边泛型参数是右边泛型参数的子类，即可赋值
in修饰后，泛型类型只能作为入参值类型

```C#
// BB继承AA

Action<AA> aa = (i) => { };
Action<BB> bb = aa;
bb(new BB());  // 调用bb时只能传入BB类，bb的调用实质是调用了aa,BB被当作AA类型使用，符合子类 --> 父类
// 只能传入子类参数被使用，最终子类会被转化为父类使用

```

## 4

### C#

#### 委托

##### .Net 1.0

1、声明属性
2、实例化赋值
3、调用

##### .Net 2.0

优化多余代码，作用域得到优化

1、声明属性
2、通过delegate标记匿名函数使用
3、调用

##### .Net 3.0

**lambda**

生成类中类然后绑定到委托中

优化多余代码，delegate标记匿名方法 --> lambda(箭头函数)  -->  可省略类型声明，自动推断  -->  可省略{} --> 省略委托属性new实例，直接写lambda(自动补全new委托代码，只需写方法参数)

**Action/Func**

最多16个参数

**Linq**

延迟计算: IEnumerable + yeild --> 状态机


##### 事件

```C#
// 事件驱动，基于委托 === 埋点？
// 暴露event属性，可以被+=绑定并且在特定事件调用
public event Action Handle;
```

## 5

### C#

#### 表达式目录树

二叉树结构，解析字符

##### 应用

- 表达式目录树拼接 + 反射 + 泛型缓存  --> 自动映射
- SQL解析
- any

### 副业

#### 选择

- 供需关系：限量销售商品，囤货二次销售（需考虑好商品的需求市场，风险控制）
    - 皮肤
    - 靓号
    - 口罩（风险把控，提前联系卖家，收取定金）

### SQL

#### %

'%%key%%' == '%key%'?

### VSCode

#### 快捷键

Ctrl + R 切换工作区（打开其他/最近项目）
Ctrl + K R 在资源管理器中打开文件
Ctrl + Tab 窗口标签页跳转
Ctrl + L 选中一行
Shift + Alt + F 代码格式化
Ctrl + Shift + L 选中所有选中的字符
Alt + F12 预览定义

Alt + Z 编辑器内容自动换行控制（超出屏幕显示后，显示换行）
Ctrl + G 跳转特定行
Ctrl + P 跳转特定文件
Ctrl + Shift + Space 快速查看内容参数定义
Ctrl + K Ctrl + F 格式化选中部分
F2 重命名变量（自动重命名所有相同变量名）
