## 1

### 代码

#### 开闭原则

通过面向接口编程实现，只包含抽离后的通用逻辑，核心逻辑则依赖于接口的实现（依赖倒置）

#### 里氏替换原则

场景：子类替代父类时？

子类可以扩展父类的功能，但不能改变父类原有的功能

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
- 子类中可以增加自己特有的方法。
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。（由于方法重载，当传入参数更宽泛时，始终是调用子类的方法，不会对父类产生影响）
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

#### 依赖导致

高层模块不直接依赖低层的实现，而是依赖于低层模块的抽象

面向接口编程，代码逻辑依赖于抽象，不依赖于具体实现，抽象的实例从外部输入

#### 接口隔离原则

接口隔离原则偏向于根据业务进行划分，单个接口会包含多个功能职责，但均指向于所对应业务所必须的接口

单一职责会被接口隔离包含，单一职责更关注松耦合，接口隔离更关注高内聚

### React

#### keepalive

[为什么不支持keepalive,官方认为这个功能容易造成内存泄漏](https://github.com/facebook/react/issues/12039)

### Web

#### 事件循环

事件循环中可能会有一个或多个任务队列，这些队列分别为了处理：

- 鼠标和键盘事件
- 其他的一些 Task

浏览器会在保持任务顺序的前提下，可能分配四分之三的优先权给鼠标和键盘事件，保证用户的输入得到最高优先级的响应，而剩下的优先级交给其他 Task，并且保证不会“饿死”它们
> 这个规范也导致 Vue 2.0.0-rc.7 这个版本 nextTick 采用了从微任务 MutationObserver 更换成宏任务 postMessage 而导致了一个 [Issue](https://github.com/vuejs/vue/issues/3771#issuecomment-249692588)
> 在用户持续滚动的情况下 nextTick 任务被延后了很久才去执行，导致动画跟不上滚动了,后续又改回microTask 去实现 nextTick

执行完microtask queue中的所有的microtask，如果microtask执行过程中又添加了microtask，那么仍然会执行新添加的microtask，当然，这个机制好像有限制，一轮microtask的执行总量似乎有限制(1000?)，数量太多就执行一部分留下的以后再执行？

定时器宏任务可能会直接跳过渲染
不是每次任务循环都会附带有渲染，有可能执行两次settimeout才进行一次渲染

resize和scroll事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上

#### AbortController

可以取消监听的事件

```js
const controller = new AbortController();
const { signal } = controller;

el.addEventListener('mousemove', callback, { signal });
el.addEventListener('pointermove', callback, { signal });
el.addEventListener('touchmove', callback, { signal });

// 之后某个时刻，移除所有的三个监听器：
controller.abort();
```

### npm

#### scripts

**环境变量**

npm run，就会自动新建一个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样

**退出码**

npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败

**传参**

使用--标识要传递参数,在执行script命令时作为后缀添加到命令中

```$ npm run lint -- --param params```

**执行顺序**

&: 并行执行
&&: 串行执行，上一个成功才执行下一个

**hook**

执行xxx命令时会自动检查scripts中是否有prexxx、postxxx的命令,最终会执行`npm run pre{xxx} && npm run {xxx} && npm run post{xxx}`
> 只支持一重的pre、post，preprexxx无效

- pre{xxx}
- post{xxx}
- prepublish: 内置hook，在执行publish前会执行
    > npm5前`npm install`（不带任何参数）前会执行`prepublish`
    > npm4后新增[prepare](https://docs.npmjs.com/cli/v6/using-npm/scripts),npm6前和`prepublish`一样
    > npm7 [`prepublish`废弃](https://docs.npmjs.com/cli/v7/using-npm/scripts)



**变量**

输出当前所有环境变量
```json
"scripts": {
    "env": "env"
}
```

- npm_lifecycle_event: 在执行命令的时候可以通过`process.env.npm_lifecycle_event`读取到，值为当前执行的script名
- process.env.npm_package{xxx}: 可以通过此变量读取package.json中的内容,`process.env.npm_package_name`,只能取到字符串，如果是对象则嵌套`process.env.npm_package_scripts_build`
- npm_config_{xxx}/process.env.npm_config_{xxx}: 读取npm config中设置的变量，淘宝源等
    > `echo npm_config_{xxx}`读取不到,process.env.npm_config_{xxx}可以

**内置命令**

- npm start是npm run start
- npm stop是npm run stop的简写
- npm test是npm run test的简写
- npm restart是npm run stop && npm run restart && npm run start的简写

### 文件

#### 类型判定

除了后缀外(后缀可修改)，可以根据二进制数据判定

对于某一些类型的文件，起始的几个字节内容都是固定的，根据这几个字节的内容就可以判断文件的类型

- JPEG:0xFF D8 FF
- PNG:0x89 50 4E 47 0D 0A 1A 0A
- GIF:0x47 49 46 38（GIF8）
- BMP:0x42 4D
- PDF:0x25 50 44 46（对应的字符串是 %PDF）

### 项目

**前期**

- 确定设计、需求范围
- 沟通确定开发时间
- 评审疑问、优化

**进行中**

- 讨论组内进行沟通，信息公开同步
- 职权明确
- 周会确定进展？
- 积极主动与开发、客户沟通推进
- 针对外部人员协作，需邮件催促通知并告知工期影响
- 考虑可能发生的问题
- 项目排期，任务排期
- 技术难点、风险点考证、确认
- 前期代码review
- 技术设计需求通知、沟通到位，使用场景、规模通知到位
- 人心、积极调动

## 2

### DSL

本质：通过限定问题域边界，从而锁定复杂度，提高编程效率

### shell

#### 代理

```export http_proxy=http://10.20.10.139:1081;export https_proxy=http://10.20.10.139:1081;```


## 6

### CSS

#### OOCSS

面向对象的CSS，是由Nicole Sullivan提出的css理论


- Separate structure and skin（分离结构和主题）减少对 HTML 结构的依赖
- Separate container and content（分离容器和内容）增加样式的复用性

特点：

- 使用class，避免使用id等
- 抽象化，命名不再特指具象的事物
- 追求复用性

#### SMACSS

##### 设计规范

- Categorizing CSS Rules（为css分类）
    - Base: 基础规范,描述的是任何场合下，页面元素的默认外观。它的定义不会用到class和ID。css reset也属于此类。常见的如normalize.css,CSS Tools
    - Layout: 作为高层级的布局，或者低层级的容器，栅格系统、左右布局等，约定了一个前缀l-/layout-来标识布局的class `.layout-header {}; .layout-container {}; .l-header {}； .l-container {}`
    - Module: 按模块（领域？）划分增加前缀 `.todolist{}; .todolist-title{};`
    - State: 描述的是任一元素在特定状态下的外观,如消息框可能有success和error等状态，有较强的复用性 `.is-hidden { display: none; }`
    - Theme Or Skin: 描述了页面主题外观，一般是指颜色、背景图。Theme Rules可以修改前面4个类别的样式，且应和前面4个类别分离开来（分开定义）（便于切换，也就是“换肤”）,如果是单独的定义使用theme前缀 `.theme-a-background`
- Naming Rules（命名规范）
    - Base: 无特殊要求
    - Layout: l-/layout-前缀
    - Module: 模块名作为前缀
    - State: is-作为前缀
    - Theme: 修饰已有的延用类名，否则theme-作为前缀
- Minimizing the Depth of Applicability（最小化适配深度）
    - 最小适配深度原则，样式尽量不依赖于html结构

#### BEMCSS

BEM 分别代表着：Block（块）、Element（元素/子块/组成部分）、Modifier（修饰符），是一种组件化的 CSS 命名方法和规范，由俄罗斯 Yandex 团队所提出

命名: .[Block 块]__[Element 元素]_[Modifier 修饰符]（常见模式）

- Block: 一个独立的实体，即通常所说的模块或组件 `header、menu、search`
    - 块名需能清晰的表达出，其用途、功能或意义，具有唯一性
- Element: 块中的组成部分，对应块中的子元素/子节点 `header title、menu item、list item`
    - 元素名需能简单的描述出，其结构、布局或意义，并且在语义上与块相关联
- Modifier: 定义块和元素的外观、状态或类型 `color、disabled、size`
    - 修饰符需能直观易懂表达出，其外观、状态或行为

#### METACSS

原子css
- 功能性css
- 原子性css

### Gitlab

#### Ad关联

组织结构变化，账号会被禁

### app

#### RN Android打包

- Android Studio 打开项目的 android 文件夹
- project 窗口选中 app
- 菜单: build -> Select Build Variant
- 弹出的 Build Variant 窗口中 MedalReactNativeApp.app（第一个）,右侧 Active Build Variant 中点击从下拉中选择需要应用的配置文件
- 菜单: build -> Build Bundle(s) / APK(s),进行打包，bundle 一般用于上架，apk 可直接发布安装
- apk 打包后，可在 android\app\build\outputs\apk\{dev | beta | ga}\{debug | release}下找到 apk,apk 会按不同架构分包

### PowerShell

无法加载文件 ******.ps1，因为在此系统中禁止执行脚本
> set-ExecutionPolicy RemoteSigned

### JS

#### 赋值操作

- 如果对象上该属性不存在，会查找原型链上的属性，然后创建一个自有属性并赋值
    > 坑：如果原型链上有此属性且writable为false，则会异常（？？），通过Object.defineProperty设置属性则不会触发原型链查找
- 如果对象上该属性已存在，则修改该属性的值，修改过程会触发该属性上的 data descriptor（writable 配置）检测或 accessor descriptor (setter 配置) 的调用。