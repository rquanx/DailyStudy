## 2

### 思维

#### 想法与实际

思考想法落实时候合理: 处理思考、想法还要看怎么落实,除了思考，还要行动
> 为什么你会想到而其他人想不到，其实其他人大概率也想到了，只是受限于各种原因无法推进
> 不要停留在自以为是阶段
> 即使发现受限于各种原因无法推进，你仍能逐步、持续的推进，就是不一样的地方


#### 内驱力

外部驱动：奖励，激励手段
内部驱动：自发的

外部驱动可能反而对内在驱动不好，使用不当会削弱，当不断通过外部刺激去驱动做事，久而久之就会形成依赖，某天缺少激励可能就放弃了


### 职业规划

一定要有职业规划，人不一定完全只做一样工作

重点：要有挑战，成就感，能让你觉得值得就行


## 4

### Typescript

#### 泛型默认值

```ts
interface IS {
  s: string;
}

function x<T = IS>(a: T) {}// IS作为默认的类型，参考js默认值

interface IX {
  c: string;
}
function x<T extends IX = IS>(a: T) {} // warn 当T增加extends限制时，默认参数也受限制
```

### 5

#### Typescript

##### extends

interface继承：只要类型包含有父interface即算继承
union type继承：对于联合类型的继承，反而是收缩为联合类型/联合类型的子集

##### readonly

readonly通过额外的关键字设定
```ts

type MyReadonly<T> = {
 readonly [k in keyof T]: T[k]
}

```

## 6

### typescript

```ts
type TupleToObject<T extends readonly any[]> = { [P in T[number]]: P }
// T[number] 可表示循环，以索引访问数据内所有数据
// T[number] 会变成联合类型

type First<T extends any[]> = T extends [first: infer A, ...arg: any[]] ? A : never;
// 使用解构，解构出第一个数据，并且通过infer自动推导定义类型

type First<T extends any[]> = T extends [] ? never : T[0];

type First<T extends any[]> = T['length'] extends 0 ? never : T[0]
// 读取属性判定

type First<T extends any[]> = T[number] extends '' ? never : T[0];


// 两个参数对比过滤出前面参数独有的
// 对于一般类型则是判定是否为子类
// 对于联合类型extends判定时会触发 自动分发
type Exclude<T, U> = T extends U ? never : T;


// 对数组类型可以使用...
type Concat<T extends any[], U extends any[]> = [...T, ...U];

type map<T> = {
  [k in keyof T]: T[k]
}
map<[]>;
// 对数组的遍历仍会生成会数组

type Includes<T extends any[], U> = "true" extends { [V in keyof T]: T[V] extends U ? "true" : false}[number] ? true : false;
type temp<T extends any[],U> = { [V in keyof T]: T[V] extends U ? "true" : false}
// 遍历T数组判定数组内数据是否有和U相等的，并且返回判定结果的数组
// 最终通过[number]遍历结果数组判定是否有为'true'
// 字符串ture是为了防止boolean和true间继承导致的无法判定

```

## 8

### azure

app regitser 注册app获取clientID
app register > 证书和secrect 中创建client secrect

### js

#### pnpm

快
pnpm自动使用npm源


#### sheetjs

excel单元格直接用null，excel会提示数据异常，并且修复后转为字符串null   sheetjs

### chrome

#### 隐身模式插件共享

chrome Allow in incognito 可以允许隐身模式使用插件


### git

git checkout -b <branch> <remot-branch>

### typescript

```ts
// as 
type MyOmit<T, K> = {
    [V in keyof T as V extends K ? never : V]: T[V]
}

```

## 10

### typescript

```ts

// 链式调用类型推断
type Chainable<Options = {}> = {
  option<K extends string, V>( // 对于字符串 先对k收缩成string,后续再使用K泛型时，可根据传入数据再次收缩为特定字符串类型，实现限定key
    key: K,
    value: V                   // 对于对象，不用进行收缩，即可自动根据泛型推断出对象限定类型
  ): Chainable<Options & { [S in K]: V }>;  // S in K 遍历时，对于字符串，相当于拿字符串作为k
  get(): Options;
};

```

## 11

### TS

```ts
type DePromise<T> = T extends Promise<infer R> ? DePromise<R> : T;

// 可以使用...对[]进行解构，从而实现对readonly或非readonly的重新分配
declare function PromiseAll<T extends any[]>(values: readonly [...T]): Promise<{
  [P in keyof T]: DePromise<T[P]>
}>;

// `${ ' ' | '\n' | '\t' }${infer R}` 字符串进行类似...的分继
type TrimLeft<S extends string> = S extends `${ ' ' | '\n' | '\t' }${infer R}` ? TrimLeft<R> : S;
```

## 12

### TS

```ts
// 模板字符串
type TrimLeft<T> = T extends `${' ' | '\n' | '\t' }${infer K}` ? TrimLeft<K> : T; 
type TrimLeft<T,R extends string = ' ' | '\n' | '\t' > = T extends `${R}${infer K}` ? TrimLeft<K> : T;


// 提取参数、提取Return
type AppendArgument<Fn extends (...args: any[]) => void, A> =
 (...args: [...rest: Parameters<Fn>, x: A]) => ReturnType<Fn>;
```

### FCM

```js
// 获取token相关信息，订阅等
fetch("https://iid.googleapis.com/iid/info/<FCMToken>?details=true",{headers: {Authorization: "key=<ServerToken>"}})
```

### SP

SP 站点/_layout / 站点/xxxx? 通过一个不存在的站点，可以跳至Page not found，可方便进入后台

## 13

### TS


#### 联合类型

**分发**

T extends U ? X : Y and when provided with a type argument where T = 'A' | 'B' 
it gets "distributed" and resolved as (A extends U ? X : Y) | (B extends U ? X : Y)

但是对于never类型，会认为空不进行分发

**never**

```ts
type NeverAssert<T> = T extends never ? 1 : 0;

type n1 = NeverAssert<string>; // 0
type n2 = NeverAssert<never>; // never
// never无法触发正常逻辑判定

// 避免由于never导致逻辑中断,即捕获never，同时让逻辑正常执行

// 改造为数组
function assertNeverArray<T>(value: T[] extends never[] ? true : false) {}

// 改造为tuple
function assertNeverTuple<T>(value: [T] extends [never] ? true : false) {}


// 数组长度
// 对于[] 可以通过T['length']获取数组长度
type Length<T extends any[]> = T['length']; 


type Key<T extends keyof any> = T; // 通过extends keyof xxx 控制T必定为 'xx' 或者 'x' | 'xx',所以T可以传递字符串

// extends keyof any和keyof T类型一致，可以在[]中通过 | 共同
type AppendToObject<T, U extends keyof any, V> = {
  [K in U | keyof T]: K extends keyof T ? T[K] : V
}

// 异常例子，后半段判定时T已经不extends推断了，所以无法读取L/R
type X<T> = T extends `${infer L}${infer R}` ? Right;

// 利用``实现toString();   bigint会自动toSting成数字字符串，不包含_ n
type toString<T extends number | string | bigint> = `${T}`;


// 联合类型可以追加
type s1 = 'a' | 'b';
type s2 = 'c' | s1;
type result = Equal<s2,'a' | 'b' | 'c'>;


// infer + Fucntion
// infer 出来的类型进行Function，会被转成宽泛的基础类型，无法被推断出窄类型（'aaa'等），需多加一层extends判定


```




### MAC

#### 软件

https://www.macwk.com/

## 14

### 笔记思考

- 纯粹是自己的思考；
- 如果是摘录来的内容，则必须自己补充了相关案例或思辨，理解

### ts

```ts
type IsFalse<T> = T extends 0 | false | [] | ''
  ? false
  : keyof T extends never
    ? false
    : true;


// 利用[...]实现数组遍历
type AnyOf<T extends readonly any[]> = T extends [infer First, ...infer Rest]
  ? IsFalse<First> extends true
    ? true
    : AnyOf<Rest>
  : false

// 限定数组类型，然后对整体数组类型进行判定，不用循环
type Falsy =
  | false
  | 0
  | ''
  | []
  | { [key: string]: never }
type AnyOf<T extends readonly any[]> = 
  T extends Falsy[] ? false : true


// 利用never判定空对象
type IsObjectEmpty<T extends {}> = T extends { [key: string]: never } ? true : false

// 触发分发
type Distribute<T> = T extends T ? [T] :false; 
type Distribute<T> = T extends any ? [T] :false;
type Distribute<T,K = T> = K extends T ? [K] :false; 
type x = Distribute<string | number>; // [string] | [number]，被分发了

type IsUnion<T,K = T> = K extends T ? IsUnNever<Exclude<T,K>> :false; 
```

## 15

### 成长

**做复杂的事情**

复杂的事情从何而来
- 主管分配：难
- 思考：让事情因为自己而与众不同？凭自己创造机会且成功

**尝试**

不要担心“做的不好”或“不完美”而不敢同步进展和风险，因为“差的信息”比“没有信息”要好很多
哪怕中途做一步错一步，也比中途“毫无音讯”强无数倍

### 项目管理

#### 进度

- 如果评估不准某个功能是否可以按期上线，一律按 “悲观” 态度给反馈
- 进来避免”我试试“、”尽力等“，只要可能来不及就直接给来不及答复
- 当给与可能但最后又没完成时，反而会带来更不好的影响
本质：风险管理、预期管理

### Web

#### Storybook

- 组件不能写const Story = xxx; 要包一层 const Story = () => xx ;
- 可解析注释但无法解析jsdoc @xx参数
- 需要export，export default无法读取
- 必须安装typescript依赖才能生成文档
- 组件简介：在组件代码前写/** */
- 属性简介：在Interface的属性前写/** */

### SP

#### Graph

**查询多选choice时，默认不支持查询**

header添加Prefer: HonorNonIndexedQueriesWarningMayFailRandomly / allowthrottleablequeries可查询，但由于此字段类型无法加索引，存在大数据量查询时可能失败
