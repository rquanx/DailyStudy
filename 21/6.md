## 2

### 思维

#### 想法与实际

思考想法落实时候合理: 处理思考、想法还要看怎么落实,除了思考，还要行动
> 为什么你会想到而其他人想不到，其实其他人大概率也想到了，只是受限于各种原因无法推进
> 不要停留在自以为是阶段
> 即使发现受限于各种原因无法推进，你仍能逐步、持续的推进，就是不一样的地方


#### 内驱力

外部驱动：奖励，激励手段
内部驱动：自发的

外部驱动可能反而对内在驱动不好，使用不当会削弱，当不断通过外部刺激去驱动做事，久而久之就会形成依赖，某天缺少激励可能就放弃了


### 职业规划

一定要有职业规划，人不一定完全只做一样工作

重点：要有挑战，成就感，能让你觉得值得就行


## 4

### Typescript

#### 泛型默认值

```ts
interface IS {
  s: string;
}

function x<T = IS>(a: T) {}// IS作为默认的类型，参考js默认值

interface IX {
  c: string;
}
function x<T extends IX = IS>(a: T) {} // warn 当T增加extends限制时，默认参数也受限制
```

### 5

#### Typescript

##### extends

interface继承：只要类型包含有父interface即算继承
union type继承：对于联合类型的继承，反而是收缩为联合类型/联合类型的子集

##### readonly

readonly通过额外的关键字设定
```ts

type MyReadonly<T> = {
 readonly [k in keyof T]: T[k]
}

```

## 6

### typescript

```ts
type TupleToObject<T extends readonly any[]> = { [P in T[number]]: P }
// T[number] 可表示循环，以索引访问数据内所有数据
// T[number] 会变成联合类型

type First<T extends any[]> = T extends [first: infer A, ...arg: any[]] ? A : never;
// 使用解构，解构出第一个数据，并且通过infer自动推导定义类型

type First<T extends any[]> = T extends [] ? never : T[0];

type First<T extends any[]> = T['length'] extends 0 ? never : T[0]
// 读取属性判定

type First<T extends any[]> = T[number] extends '' ? never : T[0];


// 两个参数对比过滤出前面参数独有的
// 对于一般类型则是判定是否为子类
// 对于联合类型extends判定时会触发 自动分发
type Exclude<T, U> = T extends U ? never : T;


// 对数组类型可以使用...
type Concat<T extends any[], U extends any[]> = [...T, ...U];

type map<T> = {
  [k in keyof T]: T[k]
}
map<[]>;
// 对数组的遍历仍会生成会数组

type Includes<T extends any[], U> = "true" extends { [V in keyof T]: T[V] extends U ? "true" : false}[number] ? true : false;
type temp<T extends any[],U> = { [V in keyof T]: T[V] extends U ? "true" : false}
// 遍历T数组判定数组内数据是否有和U相等的，并且返回判定结果的数组
// 最终通过[number]遍历结果数组判定是否有为'true'
// 字符串ture是为了防止boolean和true间继承导致的无法判定

```

## 8

### azure

app regitser 注册app获取clientID
app register > 证书和secrect 中创建client secrect

### js

#### pnpm

快
pnpm自动使用npm源


#### sheetjs

excel单元格直接用null，excel会提示数据异常，并且修复后转为字符串null   sheetjs

### chrome

#### 隐身模式插件共享

chrome Allow in incognito 可以允许隐身模式使用插件


### git

git checkout -b <branch> <remot-branch>

### typescript

```ts
// as 
type MyOmit<T, K> = {
    [V in keyof T as V extends K ? never : V]: T[V]
}

```

## 10

### typescript

```ts

// 链式调用类型推断
type Chainable<Options = {}> = {
  option<K extends string, V>( // 对于字符串 先对k收缩成string,后续再使用K泛型时，可根据传入数据再次收缩为特定字符串类型，实现限定key
    key: K,
    value: V                   // 对于对象，不用进行收缩，即可自动根据泛型推断出对象限定类型
  ): Chainable<Options & { [S in K]: V }>;  // S in K 遍历时，对于字符串，相当于拿字符串作为k
  get(): Options;
};

```