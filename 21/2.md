## 1

### 编辑器

**第四代**

解决第三代
- 没有可编辑的元素，不会触发输入事件
    > 利用隐藏的input，捕获输入事件
- 没有可编辑的元素，无法使用浏览器自带的光标
    > 自绘光标

### 领域驱动

#### 子域划分

- 核心域：其所体现的是核心服务，是代表着产品的核心竞争力。
- 支撑域：其所体现的是支撑服务，没它不行，但又达不到核心的价值，围绕着产品内部所需要，但又不能单独变更为第三方服务，即它不是一个通用的服务。
- 通用域：其所体现的中间件服务或第三方服务。本身可以通过现有的解决方案集成来完成的服务。

### CSS

#### transition

用于指定为一个或多个 CSS 属性添加过渡效果

```sass
<!-- 对max-hight进行处理 -->
{
    max-height: 0;
    transition: max-height 0.3s linear;

    &.up {
        max-height: 0;
    }
    &.down {
        max-height: 1000px;
    }
}
```

#### 动画

from == 0%
to == 100%

### Tool

FormRender
TableRender

## 2

### 管理

不要放弃每一个员工，帮助员工解决问题，帮助员工成长和提升，帮助员工搭台子唱戏，是leader最重要的职责。

### Life

#### 交际

当别人触及底线或者冒犯到时，要及时指出并制止，避免别人以为不在意从而不断践踏，导致最后爆发
> 明确人与人之间的边界线，对大家都好

#### Love

书:爱情就是一物降一物

- 表白
	不要给人压力，关系未到的时候不要给予太重的'礼'
	不要显得太刻意，真诚的去感受并且适当的说出感受
- 冒犯--回报
	逐步引导
		约吃饭，你可以随时走，不用在意
		来都来了，吃一下
		都吃饭完了，走一走
		逐步的推进
	日拱一卒
		一点点的冒犯，不要太过（请求帮点小忙，并且有回报，有来有回逐步推进）
		只帮忙无回报就...
	示弱
		表现出你对ta的信任
		自嘲敢于提出侧面表示你有信心提供更高一层的回报？
		让别人实现自身价值，ta感觉帮到你了	
-交互层级
	亲密关系的交互层级：兴趣爱好（一般朋友） 
			 价值观(特别好的朋友，目标、理想) 
			 社交关系(核心密友，分享社交关系，谈论你的朋友，可以带去和你朋友玩) 
			 情绪(只有家人和爱人才能毫无顾忌的进行情绪交流，到达这种程度即使不表白也是)
			 性(拥抱、眼神、肢体接触的交流)
			 隐秘(夫妻都很难达到的，黑暗面也能去分享，最高层级)
	总是一味的对别人好，不求回报，一般别人时会有压力（渣男、渣女除外），容易让别人厌恶，需要共同付出
	如果别人一味对你好，不求回报，你想回报，就要努力去寻找对方需要的，并帮助ta


## 3

### web

#### EventLoop

**为什么会有微任务**

引入微任务的初衷是为了解决异步回调的问题
- 方案1：将异步回调进行宏任务队列的入队操作
- 方案2：将异步回调放到当前宏任务的末尾

如果采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿

#### V8

在64位系统下，V8最多只能分配1.4G, 在 32 位系统中，最多只能分配0.7G
V8 为什么要给它设置内存上限？

- JS是单线程运行的，一旦进入到垃圾回收，其它的各种运行逻辑都要暂停
- 垃圾回收非常耗时间
> 以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上

在这么长的时间内，JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存，因为大部分情况是不会遇到操作几个G内存这样的场景的。

#### js

**值类型如何存储在栈中?**

值类型与调用栈（函数帧），一起打包存储到栈中，当函数出栈后，内存也就被释放？
> 闭包变量是存在堆内存中的,否则当函数出栈时就被释放丢失


#### 监控

**性能**

- 白屏时长
- 重要页面的http请求时间
- 重要页面的渲染时间
- 首屏加载时长

**数据**

- PV访问来量（Page View）
- UV访问数（Unique Visitor）
- 记录操作系统和浏览器
- 记录用户在页面的停留时间
- 进入当前页面的来源网页（也就是从哪进来的转化）



#### 工具

##### whislte

**应对localhost,有dev-server**

- 后端对客户端host有限制，一些功能无法通过localhost正常运行
- 业务代码针对不同host有不同处理，无法通过调试拟真线上环境

配置whislte，将特定域名映射至本地的dev-server，浏览器启用whilte代理，所有的资源都向本地读取，可以实现在真实域名情况先调试本地代码，便于debugger

**无dev-server**

配置whislte，将特定资源映射至本地文件路径

**移动端调试**

配置规则，安卓连接同一网络并设置代理，可通过插件注入调试工具

### Node

#### npm

npm config set registry https://registry.npm.taobao.org

#### yarn

yarn config set registry http://registry.npm.taobao.org/

yarn config set network-timeout 600000 -g

#### nvm

nvm 设置淘宝镜像

设置npm_mirror:
nvm npm_mirror https://npm.taobao.org/mirrors/npm/

设置node_mirror:
nvm node_mirror https://npm.taobao.org/mirrors/node/



## 4

### 编程

#### 协程

协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制，因此并没有进程/线程上下文切换的开销

### Flutter

[Flutter踩坑](https://www.jianshu.com/p/171a9660e1f9)
/packages/flutter_tools/gradle/flutter.gradle

```
project.rootProject.allprojects {
            repositories {
                maven {
                    url repository
                }
            }
        }
// to 

        project.rootProject.allprojects {
            repositories {
                maven {
                    url 'http://download.flutter.io'
                }
            }
        }

```

### Web

#### SVG

利用svg基本元素进行绘画

##### 基本元素

- `<svg>` 包裹并定义整个矢量图。`<svg>` 标签之于矢量图就如同 `<html>` 标签之于一个 web 页面，`<canvas></canvas>`。
- `<line>` 创建一条直线。
    > 属性: (x1,y1)、(x2,y2),根据设定的坐标画出线段
    > style="stroke-width: 8;" 设定笔画宽度
- `<polyline>` 创建折线。
    > 属性: points,每两个点算作一个坐标，或者以,分割，最终将所有点从起点到终点连接，终点不会连接到起点
- `<rect>` 创建矩形。
    > 属性: (x,y)、width、height,设定起点坐标 + 宽、高，形成矩形
- `<ellipse>` 创建圆和椭圆。
    > 属性: (cx,cy)、rx、ry,设定圆心坐标，x轴向半径、y轴向半径,作为圆、椭圆的参数
    > style:  style="fill:black;",设定样式，fill:black;为填充为黑色
- `<polygon>` 创建多边形。
    > 属性: points 和折线类似，只是不是线段而是图形，最终终点会与起点连接
- `<path>` 通过指定点以及点和点之间的线来创建任意形状。
    > 属性: d，路径设定
    > M 1 1  移动画笔到1,1坐标
    > L 2 2  从当前坐标画出直线到2,2
    > Z      闭合，重点与起点闭合
- `<defs>` 定义一个可复用的图形。初始情况下 `<defs>` 里面的内容是不可见的。`<defs>` 标签之于矢量图就如同 `<head>` 标签之于一个 web 页面。
    > 不可见，存放组合和模板内容
- `<g>` 将多种形状组合起来。将组合后的形状置于 `<defs>` 中可以让它能够被复用。
    > 以g包括的内容被当作一个可复用的组件使用，需设定ID
    > 属性: id唯一标识，被使用时作为引用标记
- `<symbol>` 类似于一个组合，但是拥有一些额外的特性。通常被置于 `<defs>` 标签中便于复用，可独立于`<defs>`外
    > 以symbol包括的内容被当作一个可复用的组件使用，需设定ID
    > 属性: viewBox  四个值，设定左上角位置、宽、高,裁切出对应宽高内容作为图形展示,虽然裁剪了，具体的展示效果仍需结合容器
- `<use>` 获取在 `<defs>` 中定义的复用对象并在 SVG 中显示出来
    > 属性: href引用的defs中的ID，
            (x,y) 放置位置
            width、height: 供图形放置的宽高?
- `<imaga>`
- `<mask>`
- `<animate>`
- `<animateMotion>`
- `<animateTransform>`
- `<circle>`
- `<text>`
- `<set>`
- `<marker>`

## 5

### 工具

[使用最多的免费商用图片,免注册](https://www.pexels.com/zh-cn/)

[行业报告查一查](http://report.seedsufe.com/#/report)

[文件临时传递,体验好](https://airportal.cn/)

### Base64

base64总共有64个字符，所以使用二进制进行表示时，用6比特来完整表示base64，所以6个比特的数据作为一个base64字符
> 例: 3 个字节有 24 个比特，对应于 4 个 base64 单元，即 3 个字节可由 4 个可打印字符来表示，所以进行base64转换后会占用更多的空间

### Web

#### 表单

[创建表单框架之前的小建议](https://mp.weixin.qq.com/s/Zg-Sk7VbNips8Ek2hgPL2w)

## 6

### APP

#### 导航

##### 分类

多个分类可同时存在

**标签式1：底部标签式**

场景底部导航,时代服务、微信...

优点：
1.入口清晰明显，可见性强，易于发现；可以直观了解到APP的核心功能；
2.操作路径短，便于用户在不同功能模块之间进行跳转，简单而高效；
3.符合习惯、原生控件一般会提供，开发简单；
4.优先级较高、用户使用频繁，直接展示入口内容，曝光率高。

缺点：
1.入口数量有限，常见导航3-5个，不宜超过5个。
2.占据高度空间略大，基本以文字+图标的形式展现。
3.扩展性差，不利于后期功能扩展

**标签式2：顶部标签导航式**

顶部Tap

优点：
1.扩展性好，标签的个数没有上限，不过太多的话后面点击肯定会较少
2.占据空间小：相比于底部Tab，顶部Tab一般占据的空间更小（因为不需要考虑手指点击，所以可以把区域缩小，只选用图标或者文字即可），可以把更多的空间安排给内容展示。
3.手势操作非常方便。

缺点：
1.可见性不足：这是空间占据的区域变小之后的后果。

**舵式**

舵式导航也叫点聚式,常见于导航栏中央（被加粗/样式处理明显突出），点击后弹出额外的导航

优点：
1.在默认加载的页面之外，又能够突出强调中间的入口；
2.入口直接清晰；
3.操作路径短，便于用户在不同功能模块之间进行跳转；
4.直接展示入口内的内容，内容的曝光率较高。


缺点：
1.功能模块之间没有主次之分；
2.入口数量有限，常见的标签导航多为3-5个控件，不宜超过5个；
3.扩展性差，不利于后期的功能扩展，而且占据高度空间略大。

**侧滑**

侧滑式也叫抽屉式导航、扩展菜单、侧边导航、汉堡导航

优点：
1.突出了内容的优先级；
2.节省了页面空间，将更多的屏幕空间留给了内容；
3.营造了浸入式体验，让用户的注意力更多的集中到内容上；
4.扩展性好，导航的个数没上限。


缺点:
1.用户不易发现，增加了点击次数，延长了操作路径，使用次功能需要二次点击，给用户在切换功能带来了操作成本；
2.可见性太差，不利于用户在不同的功能模块之间进行跳转；
3.不直观、不适用于主导航、如遇频繁操作的功能，用户不断开关抽屉体验不好


**宫格式导航**

支付宝首屏快捷方式，常见于二级页作为内容列表的一种图形化形式呈现，或是作为一系列工具入口的聚合

优点：
1.将入口进行聚合布局，入口清晰直接；
2.操作路径较短，用户可以便捷的在不同的功能模块之间进行跳转；
3.扩展性非常好，能够添加多个入口；（运营位、广告位、内容块、设置等）
4.能够直接给出功能模块的更新提示，跨平台不受平台限制。


缺点：
1.每个宫格相互独立，它们的信息间也没有任何交集，无法跳转互通；
2.当排布过多的时候，用户容易眼花缭乱，选择压力较大；


**列表式导航**

我的、设置功能菜单

优点：
1.结构清晰，易于理解，冷静高效；


缺点:
1.入口之间为平行的关系，无优先级之分；
2.排版方式固定。
3.不利于用户在不同的功能模块之间进行跳转


**轮盘式导航**

浮动按钮弹出导航

优点：
1.界面清晰，操作简单；
2.交互性效果给人耳目一新的感觉。

缺点:
1.展示的内容数量有限；
2.开发实现难度大。

**下拉式导航**

外卖app高级筛选，一般位于产品顶部，通过点击呼出导航菜单，通过点击一个下拉图标引出一串列表的形式作为二级导航，因其收起来体积较小，能隐藏更多信息，有时会和滑动导航一起出现

优点：
1.菜单与界面的连贯性比抽屉式要好，容易让用户感知当前位置；

缺点：
1.位于屏幕上方，相对隐蔽且不能结合手势操作，不适合于频繁的切换功能使用；
2.考虑到导航菜单的可用面积较小，所以一般采用列表的形式展示菜单内容

**瀑布式导航**

瀑布流

优点：
1.页面浏览时产生流畅感体验；排版布局多变；
2.沉浸式体验。

缺点：
1.不适合层级架构复杂的产品,容易产生疲劳感

**组合式导航**

多个导航方式用在一起

优点：
1.各种导航进行组合式排版，适用于内容较多的APP；
2.能直接给出页面的入口，便于用户进行跳转。


缺点：
1.功能入口多，用户找寻不方便，优先级不高。

2.App变“重”

### Web

#### CSS

stylelint规范css

#### 工程化

##### 监控

- sdk
    - 自动采集、上报
    - 自定义采集
- 智能分析
    - 日志清洗（黑名单、白名单、规则过滤）
        - 第三方脚本注入
        - 容器脚本的注入
        - 手机制造商脚本注入
    - 日志分组（应用、类型...分类）
    - 日志统计（统计规则定义指标）
- 报警（报警指标界线）
    - 电话
    - 信息
    - 邮件

### 算法

#### 有效括号

前提：纯'('和')'

1、栈匹配（需要存储所有(，空间复杂度O(n)）
2、变量计数, ( + 1 ,) -1 , 空间复杂度O(1)

#### 最长有效括号

前提：纯'('和')'

1、暴力计算多重循环，从起点开始每次以索引位置为起点进行计算最大长度，失败后从新的起点重新计算(时间复杂度为 O(n^2)，空间复杂度为 O(1))
2、栈存放下标，-1入栈 ,( 的下标入栈, ) 则出栈并且计算当前与栈顶计算的最大长度,当栈空时则清空以当前下标入栈重新计算,时间复杂度为 O(n)，空间复杂度为 O(n)
3、不用栈，同样利用变量存储计算，记录括号数 + 匹配数，( + 1, ) - 1，并且计算匹配数量,括号变量不为0，(加一 )减一，减一不为0时，匹配数加一。加一小于0时，括号变量重置为0

### Flutter

#### Components

**AnimatedCrossFade**

通过状态，可进行两个局部组件切换，可设置动画，另类导航?

**Transform**

对元素进行旋转弧度

坐标轴方向，手机竖直方向为z，直面屏幕为x

Matrix4.rotationX 
Matrix4.rotationY
Matrix4.rotationZ

**CurvedAnimation**

曲线动画生成器
根据传入的曲线函数和动画控制器，不断调用动画运行

**Curves**

动画曲线类

**AnimationController**

动画控制器

addListener：动画运行时调用（每次动画变动）
addStatusListener：监听动画状态

**ExpansionTile**

伸展菜单

**RotationTransition**

旋转

**InteractiveViewer**

可移动、缩放容器

**TweenSequence**

动画序列,组合多个动画?


#### 动画

- 补间 (Tween) 
    > 补间动画是介于两者之间的简称，在补间动画中定义起点和终点、时间点以及定义时间变化和速度的曲线，然后由系统计算如何从开始点到结束点
- 物理 (Physics) 
    > 物理动画是运动被模拟为与真实世界的行为相似，比如抛一件物体，它落在什么地方取决于这个物体的重量，抛出去的速度以及这个物体与地面的高度，类似数学中的抛物线运动轨迹

#### 尺寸

flutter中默认组件尺寸单位都是dp(devicePixelRatio)

devicePixelRatio: 物理像素 / 逻辑像素（px），始终可能存在溢出


## 8

### Web

#### React

##### useState

参数传入为函数时，只有挂载初始化时会调用,惰性求值

#### DOM

**地址**

URL(解析url)
URLSearchParams(解析查询参数)

**地理位置**

navigator.geolocation

**浏览器通知**

Notifications

### Git

#### commit

**修改commit信息**

git commit --amend
> 打开编辑器

git commit --amend -m "xxx" 
> 不打开编辑器

#### 分支

**删除远程分支**

git push origin --delete fea-xx

**分支重命名**
git branch -m <oldbranch> <newbranch>

**检查分支是否包含特定commit**

git branch --contains <commit-id>

#### 撤回

**已将更改提交到本地，需要撤回提交，更改项还原到暂存区**

git reset --soft [<commit-id>/HEAD~n>]
> HEAD~n 前几个?

**已将更改提交到本地，需要撤回提交，更改项还原到工作区**

git reset --mixed [<commit-id>/HEAD~n>]

**已将更改提交到本地，需要撤回提交，并且清空暂存区和工作区**

git reset --hard [<commit-id>/HEAD~n>]

**合并撤回**

撤回到merge前的特定commit

## 9

### 工具

#### +1s

- 在 GitHub 域名后面加 1s 可以直接使用 vscode online 打开仓库代码，例如 https://github1s.com/justjavac/1s
- 当你看到喜欢的 YouTube 视频时，可以在 youtube 后面加 1s，直接下载此视频,https://www.youtube1s.com/watch?v=RGOj5yH7evk

### Web

#### 体验

一个网页从访问到呈现出来，用户能容忍的等待时间大概是3~5s

### git

#### ignore

每个目录都可以有自己的ignore，当仓库存放多端代码时可以各自管理

#### commit 

**需忽略的文件已提交上去**

1、删除本地文件commit
2、git rm --cached filename,不需要删除本地文件

**空文件夹**

git会忽略空文件夹,空文件夹下随便建个文件即可/.gitkeep

**创建空分支，文件保持，但无历史**

git checkout --orphan emptyBranchName

该命令会生成一个叫 emptybranch 的分支，该分支会包含父分支的所有文件。但新的分支不会指向任何以前的提交，就是它没有历史，如果你提交当前内容，那么这次提交就是这个分支的首次提交。

想要空分支，所以需要把当前内容全部删除，用 git 命令
git rm -rf .

**自动定位bug commit**

git bisect start [终点哈希] [起点哈希]
> 开始后会自动用二分法进行

git bisect good
> 当前段正常，继续往前进行二分法

git bisect bad
> 已经出现错误，往后进行二分法

一直到没有时会提示 xxx is the first bad commit

git bisect reset
> 退出查找

git bisect run script
> 可以执行自定义脚本,然后执行单元测试，就可以自动化找出异常commit



#### SSH

1、生成ssh-keygen -t rsa -C "xxxxx@xxxxx.com" 
2、查看.pub，cat ~/.ssh/id_rsa.pub（windows user/.ssh）
3、赋值内容粘贴到github/gitlab中
4、测试是否联通,ssh -T git@github.com


## 10

### 算法

#### 邻接矩阵

邻接矩阵是一个用来描绘顶点与边关系的数据结构。
本质是一个二维数组，适合用来处理最小数据单元之间的关联关系。
主要应用在迷宫、简单地图、级联表单等等图形化场景

邻接矩阵有两种模式：无向图以及有向图。

- 无向图主要的特点是不表示方向点与点之间可以双向流通
- 有向图则包含方向两点间可单向亦可双向。

##### 联动表单

添加购物车时选择产品类型，通常存在多种互不相关的分类，每个分类下有多个选项，对各个分类的选项进行组合选择最终得出产品
> 有的组合不可选,选择某一个分类后，只有可选选项可继续选择
> 选择时各个分类没有顺序

**方案一（当分类选择固定先后顺序后）**

后端返回分类 + 分类嵌套对象

1、数据构建key、value,最终层value为id
2、存储选中的各层级key
3、根据选中keys,逐层显示

**方案二（邻接矩阵,无顺序要求）**

无向图

后端返回分类 + 商品的id及其对应的标签

1、根据分类渲染显示
2、商品的id及其对应的标签 构建矩阵
3、初始化默认取第一个商品/入参商品作为默认选中项
4、每次点击选中/取消选中时根据当前选中的标签，计算出可选项（当前选中项各自计算结果的交集）

##### 地图（无权重）

有向图

1、基于各个点之间的方向组合出矩阵,可联通为1,不可联通为0
2、从起点开始，利用深度/广度算法遍历计算，找出到达终点的节点数组
> 为何不用树? 由于个节点间有方向，但无明确的根节点，如果以起点为根节点，每次切换都需要重新构造？图则是可固定通用？

##### 地图（有权重）

有向图

迪科斯彻算法