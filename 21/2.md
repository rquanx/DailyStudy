## 1

### 编辑器

**第四代**

解决第三代

- 没有可编辑的元素，不会触发输入事件
  > 利用隐藏的 input，捕获输入事件
- 没有可编辑的元素，无法使用浏览器自带的光标
  > 自绘光标

### 领域驱动

#### 子域划分

- 核心域：其所体现的是核心服务，是代表着产品的核心竞争力。
- 支撑域：其所体现的是支撑服务，没它不行，但又达不到核心的价值，围绕着产品内部所需要，但又不能单独变更为第三方服务，即它不是一个通用的服务。
- 通用域：其所体现的中间件服务或第三方服务。本身可以通过现有的解决方案集成来完成的服务。

### CSS

#### transition

用于指定为一个或多个 CSS 属性添加过渡效果

```sass
<!-- 对max-hight进行处理 -->
{
    max-height: 0;
    transition: max-height 0.3s linear;

    &.up {
        max-height: 0;
    }
    &.down {
        max-height: 1000px;
    }
}
```

#### 动画

from == 0%
to == 100%

### Tool

FormRender
TableRender

## 2

### 管理

不要放弃每一个员工，帮助员工解决问题，帮助员工成长和提升，帮助员工搭台子唱戏，是 leader 最重要的职责。

### Life

#### 交际

当别人触及底线或者冒犯到时，要及时指出并制止，避免别人以为不在意从而不断践踏，导致最后爆发

> 明确人与人之间的边界线，对大家都好

#### Love

书:爱情就是一物降一物

- 表白
  不要给人压力，关系未到的时候不要给予太重的'礼'
  不要显得太刻意，真诚的去感受并且适当的说出感受
- 冒犯--回报
  逐步引导
  约吃饭，你可以随时走，不用在意
  来都来了，吃一下
  都吃饭完了，走一走
  逐步的推进
  日拱一卒
  一点点的冒犯，不要太过（请求帮点小忙，并且有回报，有来有回逐步推进）
  只帮忙无回报就...
  示弱
  表现出你对 ta 的信任
  自嘲敢于提出侧面表示你有信心提供更高一层的回报？
  让别人实现自身价值，ta 感觉帮到你了 -交互层级
  亲密关系的交互层级：兴趣爱好（一般朋友）
  价值观(特别好的朋友，目标、理想)
  社交关系(核心密友，分享社交关系，谈论你的朋友，可以带去和你朋友玩)
  情绪(只有家人和爱人才能毫无顾忌的进行情绪交流，到达这种程度即使不表白也是)
  性(拥抱、眼神、肢体接触的交流)
  隐秘(夫妻都很难达到的，黑暗面也能去分享，最高层级)
  总是一味的对别人好，不求回报，一般别人时会有压力（渣男、渣女除外），容易让别人厌恶，需要共同付出
  如果别人一味对你好，不求回报，你想回报，就要努力去寻找对方需要的，并帮助 ta

## 3

### web

#### EventLoop

**为什么会有微任务**

引入微任务的初衷是为了解决异步回调的问题

- 方案 1：将异步回调进行宏任务队列的入队操作
- 方案 2：将异步回调放到当前宏任务的末尾

如果采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿

#### V8

在 64 位系统下，V8 最多只能分配 1.4G, 在 32 位系统中，最多只能分配 0.7G
V8 为什么要给它设置内存上限？

- JS 是单线程运行的，一旦进入到垃圾回收，其它的各种运行逻辑都要暂停
- 垃圾回收非常耗时间
  > 以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上

在这么长的时间内，JS 代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存，因为大部分情况是不会遇到操作几个 G 内存这样的场景的。

#### js

**值类型如何存储在栈中?**

值类型与调用栈（函数帧），一起打包存储到栈中，当函数出栈后，内存也就被释放？

> 闭包变量是存在堆内存中的,否则当函数出栈时就被释放丢失

#### 监控

**性能**

- 白屏时长
- 重要页面的 http 请求时间
- 重要页面的渲染时间
- 首屏加载时长

**数据**

- PV 访问来量（Page View）
- UV 访问数（Unique Visitor）
- 记录操作系统和浏览器
- 记录用户在页面的停留时间
- 进入当前页面的来源网页（也就是从哪进来的转化）

#### 工具

##### whislte

**应对 localhost,有 dev-server**

- 后端对客户端 host 有限制，一些功能无法通过 localhost 正常运行
- 业务代码针对不同 host 有不同处理，无法通过调试拟真线上环境

配置 whislte，将特定域名映射至本地的 dev-server，浏览器启用 whilte 代理，所有的资源都向本地读取，可以实现在真实域名情况先调试本地代码，便于 debugger

**无 dev-server**

配置 whislte，将特定资源映射至本地文件路径

**移动端调试**

配置规则，安卓连接同一网络并设置代理，可通过插件注入调试工具

### Node

#### npm

npm config set registry https://registry.npm.taobao.org

#### yarn

yarn config set registry http://registry.npm.taobao.org/

yarn config set network-timeout 600000 -g

#### nvm

nvm 设置淘宝镜像

设置 npm_mirror:
nvm npm_mirror https://npm.taobao.org/mirrors/npm/

设置 node_mirror:
nvm node_mirror https://npm.taobao.org/mirrors/node/

## 4

### 编程

#### 协程

协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制，因此并没有进程/线程上下文切换的开销

### Flutter

[Flutter 踩坑](https://www.jianshu.com/p/171a9660e1f9)
/packages/flutter_tools/gradle/flutter.gradle

```
project.rootProject.allprojects {
            repositories {
                maven {
                    url repository
                }
            }
        }
// to

        project.rootProject.allprojects {
            repositories {
                maven {
                    url 'http://download.flutter.io'
                }
            }
        }

```

### Web

#### SVG

利用 svg 基本元素进行绘画

##### 基本元素

- `<svg>` 包裹并定义整个矢量图。`<svg>` 标签之于矢量图就如同 `<html>` 标签之于一个 web 页面，`<canvas></canvas>`。
- `<line>` 创建一条直线。
  > 属性: (x1,y1)、(x2,y2),根据设定的坐标画出线段
  > style="stroke-width: 8;" 设定笔画宽度
- `<polyline>` 创建折线。
  > 属性: points,每两个点算作一个坐标，或者以,分割，最终将所有点从起点到终点连接，终点不会连接到起点
- `<rect>` 创建矩形。
  > 属性: (x,y)、width、height,设定起点坐标 + 宽、高，形成矩形
- `<ellipse>` 创建圆和椭圆。
  > 属性: (cx,cy)、rx、ry,设定圆心坐标，x 轴向半径、y 轴向半径,作为圆、椭圆的参数
  > style: style="fill:black;",设定样式，fill:black;为填充为黑色
- `<polygon>` 创建多边形。
  > 属性: points 和折线类似，只是不是线段而是图形，最终终点会与起点连接
- `<path>` 通过指定点以及点和点之间的线来创建任意形状。
  > 属性: d，路径设定
  > M 1 1 移动画笔到 1,1 坐标
  > L 2 2 从当前坐标画出直线到 2,2
  > Z 闭合，重点与起点闭合
- `<defs>` 定义一个可复用的图形。初始情况下 `<defs>` 里面的内容是不可见的。`<defs>` 标签之于矢量图就如同 `<head>` 标签之于一个 web 页面。
  > 不可见，存放组合和模板内容
- `<g>` 将多种形状组合起来。将组合后的形状置于 `<defs>` 中可以让它能够被复用。
  > 以 g 包括的内容被当作一个可复用的组件使用，需设定 ID
  > 属性: id 唯一标识，被使用时作为引用标记
- `<symbol>` 类似于一个组合，但是拥有一些额外的特性。通常被置于 `<defs>` 标签中便于复用，可独立于`<defs>`外
  > 以 symbol 包括的内容被当作一个可复用的组件使用，需设定 ID
  > 属性: viewBox 四个值，设定左上角位置、宽、高,裁切出对应宽高内容作为图形展示,虽然裁剪了，具体的展示效果仍需结合容器
- `<use>` 获取在 `<defs>` 中定义的复用对象并在 SVG 中显示出来
  > 属性: href 引用的 defs 中的 ID，
            (x,y) 放置位置
            width、height: 供图形放置的宽高?
- `<imaga>`
- `<mask>`
- `<animate>`
- `<animateMotion>`
- `<animateTransform>`
- `<circle>`
- `<text>`
- `<set>`
- `<marker>`

## 5

### 工具

[使用最多的免费商用图片,免注册](https://www.pexels.com/zh-cn/)

[行业报告查一查](http://report.seedsufe.com/#/report)

[文件临时传递,体验好](https://airportal.cn/)

### Base64

base64 总共有 64 个字符，所以使用二进制进行表示时，用 6 比特来完整表示 base64，所以 6 个比特的数据作为一个 base64 字符

> 例: 3 个字节有 24 个比特，对应于 4 个 base64 单元，即 3 个字节可由 4 个可打印字符来表示，所以进行 base64 转换后会占用更多的空间

### Web

#### 表单

[创建表单框架之前的小建议](https://mp.weixin.qq.com/s/Zg-Sk7VbNips8Ek2hgPL2w)

## 6

### APP

#### 导航

##### 分类

多个分类可同时存在

**标签式 1：底部标签式**

场景底部导航,时代服务、微信...

优点： 1.入口清晰明显，可见性强，易于发现；可以直观了解到 APP 的核心功能； 2.操作路径短，便于用户在不同功能模块之间进行跳转，简单而高效； 3.符合习惯、原生控件一般会提供，开发简单； 4.优先级较高、用户使用频繁，直接展示入口内容，曝光率高。

缺点： 1.入口数量有限，常见导航 3-5 个，不宜超过 5 个。 2.占据高度空间略大，基本以文字+图标的形式展现。 3.扩展性差，不利于后期功能扩展

**标签式 2：顶部标签导航式**

顶部 Tap

优点： 1.扩展性好，标签的个数没有上限，不过太多的话后面点击肯定会较少 2.占据空间小：相比于底部 Tab，顶部 Tab 一般占据的空间更小（因为不需要考虑手指点击，所以可以把区域缩小，只选用图标或者文字即可），可以把更多的空间安排给内容展示。 3.手势操作非常方便。

缺点： 1.可见性不足：这是空间占据的区域变小之后的后果。

**舵式**

舵式导航也叫点聚式,常见于导航栏中央（被加粗/样式处理明显突出），点击后弹出额外的导航

优点： 1.在默认加载的页面之外，又能够突出强调中间的入口； 2.入口直接清晰； 3.操作路径短，便于用户在不同功能模块之间进行跳转； 4.直接展示入口内的内容，内容的曝光率较高。

缺点： 1.功能模块之间没有主次之分； 2.入口数量有限，常见的标签导航多为 3-5 个控件，不宜超过 5 个； 3.扩展性差，不利于后期的功能扩展，而且占据高度空间略大。

**侧滑**

侧滑式也叫抽屉式导航、扩展菜单、侧边导航、汉堡导航

优点： 1.突出了内容的优先级； 2.节省了页面空间，将更多的屏幕空间留给了内容； 3.营造了浸入式体验，让用户的注意力更多的集中到内容上； 4.扩展性好，导航的个数没上限。

缺点: 1.用户不易发现，增加了点击次数，延长了操作路径，使用次功能需要二次点击，给用户在切换功能带来了操作成本； 2.可见性太差，不利于用户在不同的功能模块之间进行跳转； 3.不直观、不适用于主导航、如遇频繁操作的功能，用户不断开关抽屉体验不好

**宫格式导航**

支付宝首屏快捷方式，常见于二级页作为内容列表的一种图形化形式呈现，或是作为一系列工具入口的聚合

优点： 1.将入口进行聚合布局，入口清晰直接； 2.操作路径较短，用户可以便捷的在不同的功能模块之间进行跳转； 3.扩展性非常好，能够添加多个入口；（运营位、广告位、内容块、设置等） 4.能够直接给出功能模块的更新提示，跨平台不受平台限制。

缺点： 1.每个宫格相互独立，它们的信息间也没有任何交集，无法跳转互通； 2.当排布过多的时候，用户容易眼花缭乱，选择压力较大；

**列表式导航**

我的、设置功能菜单

优点： 1.结构清晰，易于理解，冷静高效；

缺点: 1.入口之间为平行的关系，无优先级之分； 2.排版方式固定。 3.不利于用户在不同的功能模块之间进行跳转

**轮盘式导航**

浮动按钮弹出导航

优点： 1.界面清晰，操作简单； 2.交互性效果给人耳目一新的感觉。

缺点: 1.展示的内容数量有限； 2.开发实现难度大。

**下拉式导航**

外卖 app 高级筛选，一般位于产品顶部，通过点击呼出导航菜单，通过点击一个下拉图标引出一串列表的形式作为二级导航，因其收起来体积较小，能隐藏更多信息，有时会和滑动导航一起出现

优点： 1.菜单与界面的连贯性比抽屉式要好，容易让用户感知当前位置；

缺点： 1.位于屏幕上方，相对隐蔽且不能结合手势操作，不适合于频繁的切换功能使用； 2.考虑到导航菜单的可用面积较小，所以一般采用列表的形式展示菜单内容

**瀑布式导航**

瀑布流

优点： 1.页面浏览时产生流畅感体验；排版布局多变； 2.沉浸式体验。

缺点： 1.不适合层级架构复杂的产品,容易产生疲劳感

**组合式导航**

多个导航方式用在一起

优点： 1.各种导航进行组合式排版，适用于内容较多的 APP； 2.能直接给出页面的入口，便于用户进行跳转。

缺点： 1.功能入口多，用户找寻不方便，优先级不高。

2.App 变“重”

### Web

#### CSS

stylelint 规范 css

#### 工程化

##### 监控

- sdk
  - 自动采集、上报
  - 自定义采集
- 智能分析
  - 日志清洗（黑名单、白名单、规则过滤）
    - 第三方脚本注入
    - 容器脚本的注入
    - 手机制造商脚本注入
  - 日志分组（应用、类型...分类）
  - 日志统计（统计规则定义指标）
- 报警（报警指标界线）
  - 电话
  - 信息
  - 邮件

### 算法

#### 有效括号

前提：纯'('和')'

1、栈匹配（需要存储所有(，空间复杂度 O(n)）
2、变量计数, ( + 1 ,) -1 , 空间复杂度 O(1)

#### 最长有效括号

前提：纯'('和')'

1、暴力计算多重循环，从起点开始每次以索引位置为起点进行计算最大长度，失败后从新的起点重新计算(时间复杂度为 O(n^2)，空间复杂度为 O(1))
2、栈存放下标，-1 入栈 ,( 的下标入栈, ) 则出栈并且计算当前与栈顶计算的最大长度,当栈空时则清空以当前下标入栈重新计算,时间复杂度为 O(n)，空间复杂度为 O(n)
3、不用栈，同样利用变量存储计算，记录括号数 + 匹配数，( + 1, ) - 1，并且计算匹配数量,括号变量不为 0，(加一 )减一，减一不为 0 时，匹配数加一。加一小于 0 时，括号变量重置为 0

### Flutter

#### Components

**AnimatedCrossFade**

通过状态，可进行两个局部组件切换，可设置动画，另类导航?

**Transform**

对元素进行旋转弧度

坐标轴方向，手机竖直方向为 z，直面屏幕为 x

Matrix4.rotationX
Matrix4.rotationY
Matrix4.rotationZ

**CurvedAnimation**

曲线动画生成器
根据传入的曲线函数和动画控制器，不断调用动画运行

**Curves**

动画曲线类

**AnimationController**

动画控制器

addListener：动画运行时调用（每次动画变动）
addStatusListener：监听动画状态

**ExpansionTile**

伸展菜单

**RotationTransition**

旋转

**InteractiveViewer**

可移动、缩放容器

**TweenSequence**

动画序列,组合多个动画?

#### 动画

- 补间 (Tween)
  > 补间动画是一种预先定义物体运动的起点和终点，物体的运动方式，运动时间，时间曲线，然后从起点过渡到终点的动画
  > 补间动画是介于两者之间的简称，在补间动画中定义起点和终点、时间点以及定义时间变化和速度的曲线，然后由系统计算如何从开始点到结束点
- 物理 (Physics)
  > 物理动画是运动被模拟为与真实世界的行为相似，比如抛一件物体，它落在什么地方取决于这个物体的重量，抛出去的速度以及这个物体与地面的高度，类似数学中的抛物线运动轨迹

#### 尺寸

flutter 中默认组件尺寸单位都是 dp(devicePixelRatio)

devicePixelRatio: 物理像素 / 逻辑像素（px），始终可能存在溢出

## 8

### Web

#### React

##### useState

参数传入为函数时，只有挂载初始化时会调用,惰性求值

#### DOM

**地址**

URL(解析 url)
URLSearchParams(解析查询参数)

**地理位置**

navigator.geolocation

**浏览器通知**

Notifications

### Git

#### commit

**修改 commit 信息**

git commit --amend

> 打开编辑器

git commit --amend -m "xxx"

> 不打开编辑器

#### 分支

**删除远程分支**

git push origin --delete fea-xx

**分支重命名**
git branch -m <oldbranch> <newbranch>

**检查分支是否包含特定 commit**

git branch --contains <commit-id>

#### 撤回

**已将更改提交到本地，需要撤回提交，更改项还原到暂存区**

git reset --soft [<commit-id>/HEAD~n>]

> HEAD~n 前几个?

**已将更改提交到本地，需要撤回提交，更改项还原到工作区**

git reset --mixed [<commit-id>/HEAD~n>]

**已将更改提交到本地，需要撤回提交，并且清空暂存区和工作区**

git reset --hard [<commit-id>/HEAD~n>]

**合并撤回**

撤回到 merge 前的特定 commit

## 9

### 工具

#### +1s

- 在 GitHub 域名后面加 1s 可以直接使用 vscode online 打开仓库代码，例如 https://github1s.com/justjavac/1s
- 当你看到喜欢的 YouTube 视频时，可以在 youtube 后面加 1s，直接下载此视频,https://www.youtube1s.com/watch?v=RGOj5yH7evk

### Web

#### 体验

一个网页从访问到呈现出来，用户能容忍的等待时间大概是 3~5s

### git

#### ignore

每个目录都可以有自己的 ignore，当仓库存放多端代码时可以各自管理

#### commit

**需忽略的文件已提交上去**

1、删除本地文件 commit
2、git rm --cached filename,不需要删除本地文件

**空文件夹**

git 会忽略空文件夹,空文件夹下随便建个文件即可/.gitkeep

**创建空分支，文件保持，但无历史**

git checkout --orphan emptyBranchName

该命令会生成一个叫 emptybranch 的分支，该分支会包含父分支的所有文件。但新的分支不会指向任何以前的提交，就是它没有历史，如果你提交当前内容，那么这次提交就是这个分支的首次提交。

想要空分支，所以需要把当前内容全部删除，用 git 命令
git rm -rf .

**自动定位 bug commit**

git bisect start [终点哈希] [起点哈希]

> 开始后会自动用二分法进行

git bisect good

> 当前段正常，继续往前进行二分法

git bisect bad

> 已经出现错误，往后进行二分法

一直到没有时会提示 xxx is the first bad commit

git bisect reset

> 退出查找

git bisect run script

> 可以执行自定义脚本,然后执行单元测试，就可以自动化找出异常 commit

#### SSH

1、生成 ssh-keygen -t rsa -C "xxxxx@xxxxx.com"
2、查看.pub，cat ~/.ssh/id_rsa.pub（windows user/.ssh）
3、赋值内容粘贴到 github/gitlab 中
4、测试是否联通,ssh -T git@github.com

## 10

### 算法

#### 邻接矩阵

邻接矩阵是一个用来描绘顶点与边关系的数据结构。
本质是一个二维数组，适合用来处理最小数据单元之间的关联关系。
主要应用在迷宫、简单地图、级联表单等等图形化场景

邻接矩阵有两种模式：无向图以及有向图。

- 无向图主要的特点是不表示方向点与点之间可以双向流通
- 有向图则包含方向两点间可单向亦可双向。

##### 联动表单

添加购物车时选择产品类型，通常存在多种互不相关的分类，每个分类下有多个选项，对各个分类的选项进行组合选择最终得出产品

> 有的组合不可选,选择某一个分类后，只有可选选项可继续选择
> 选择时各个分类没有顺序

**方案一（当分类选择固定先后顺序后）**

后端返回分类 + 分类嵌套对象

1、数据构建 key、value,最终层 value 为 id
2、存储选中的各层级 key
3、根据选中 keys,逐层显示

**方案二（邻接矩阵,无顺序要求）**

无向图

后端返回分类 + 商品的 id 及其对应的标签

1、根据分类渲染显示
2、商品的 id 及其对应的标签 构建矩阵
3、初始化默认取第一个商品/入参商品作为默认选中项
4、每次点击选中/取消选中时根据当前选中的标签，计算出可选项（当前选中项各自计算结果的交集）

##### 地图（无权重）

有向图

1、基于各个点之间的方向组合出矩阵,可联通为 1,不可联通为 0
2、从起点开始，利用深度/广度算法遍历计算，找出到达终点的节点数组

> 为何不用树? 由于个节点间有方向，但无明确的根节点，如果以起点为根节点，每次切换都需要重新构造？图则是可固定通用？

##### 地图（有权重）

有向图

迪科斯彻算法

## 10

### Flutter

#### Canvas

**CurveTween**

曲线动画

**TextPainter**

绘制文字

**画形状**

```dart

// 定义形状，矩形
final Rect rect = Rect.fromLTWH(50.0, 50.0, 100.0, 100.0);
// 指定画笔的样式
final Paint paint = Paint()
  ..color = Colors.orange
  ..strokeWidth = 4.0
  ..style = PaintingStyle.stroke
  ..isAntiAlias = true;
// drawRect绘出形状
canvas.drawRect(rect, paint);

```

**画出方格**

```dart

// 获取边界
final double sw = size.width;
final double sh = size.height;

// 使用 Paint 定义路径的样式
final Paint paint = Paint()
  ..color = Colors.black87
  ..style = PaintingStyle.stroke
  ..strokeWidth = 1.0;
final Path path = Path();
var xGap = 10.0;
var yGap = 10.0;

// 画竖线，横坐标从0到最大，间隔xGap，从(x,0) 画到 (x,hmax)
for (var x = 0.0; x <= sw; x += xGap) {
  path
    ..moveTo(x, 0)
    ..lineTo(x, sh);
}

// 画横线，纵坐标从0到最大，间隔yGap，从(0,y) 画到 (wmax,y)
for (var y = 0.0; y <= sh; y += yGap) {
  path
    ..moveTo(0, y)
    ..lineTo(sw, y);
}
// 使用 drawPath 方法绘制路径
canvas.drawPath(path, paint);
```

**画圆**

drawCircle

#### 字体

FLutter 字体默认不会跟随系统， Android 端默认使用 Roboto，而在 iOS 端默认使用 San Francisco

**静态加载**

```yaml
fonts:
  - family: "xxx"
    fonts:
      - assest: "xxx"
```

**动态加载**

```dart
// FontLoader加载字体,load font file
Future loadFontFile() async {
    var fontLoader = FontLoader('FenPinYinTi2');
    fontLoader.addFont(fetchFontByteData());
    await fontLoader.load().catchError((e) {
      loge("loadFontFile erro: $e");
    });
    setState(() {});
}

// 从assets中加载，也可以通过NetworkAssetBundle 从网络获取，或dio请求获取
Future<ByteData> fetchFontByteData() => DefaultAssetBundle.of(context).load('fonts/FenPinYinTi2.ttf');
```

**字体使用**

- 全局或局部，使用 themeData 中的 fontFamily
- 更细颗粒的使用，TextStyle 的 fontFamily

### web

#### 应用

##### 登录表单

[登录表单最佳实践](https://zhuanlan.zhihu.com/p/349805214)

## 11

### 自动化测试

自动化的收益 = 迭代次数 _ 全手动执行成本 - 首次自动化成本 - 维护次数 _ 维护成本

#### 测试方式

- 黑盒测试:一般也被称为功能测试，黑盒测试要求测试人员将程序看作一个整体，不考虑其内部结构和特性，只是按照期望验证程序是否能正常工作。黑盒测试更接近用户使用的真实场景，因为对于用户来说，程序的内部是不可见的
  > 测试方法：等价类划分、边界值分析、错误推测、异常分析等
- 白盒测试:基于代码本身的测试，一般指对代码逻辑结构的测试。白盒测试是在了解代码结构的前提下进行的测试，目的是遍历尽可能多的可执行路径，得出测试数据。白盒测试方法比较多，主要是逻辑覆盖，即检查代码的每一行、每一次判断结果
  > 语句覆盖 （让程序执行到每一行语句）
  > 判定覆盖 （让每一个判断语句满足真假）
  > 条件覆盖 （让每一个判断语句里面的每一个条件都取到真假值）
  > 判定/条件覆盖 （同时满足 2 和 3）
  > 条件组合覆盖 （判断语句中条件的每种组合至少出现一次）
  > 路径覆盖 （覆盖程序每一条执行路径）

#### 分类

- 单元测试: 对程序中最小可测试单元进行的测试，一般而言是指对函数进行的测试,对代码内部逻辑进行测试，因此更多的使用白盒的测试方式
- 集成测试: 将已测试过的单元测试函数进行组合集成暴露出的高层函数或类的封装，对这些函数或类进行的测试
- 端到端测试: 完全作为一个用户一样将程序作为一个完全的黑盒，打开应用程序模拟输入，检查功能以及界面是否正确,难点: 环境、元素查找、操作等待、操作取代断言
- UI 测试

从顶向下测试的复杂度将不断提高，另一方面测试的收益反而不断降低的

#### 应用场景

- 公共库类的开发维护
- 中长期项目的迭代/重构
- 引用了不可控的第三方依赖

#### 思想

- TDD：Test-Driven Development（测试驱动开发）：TDD 则要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行
- BDD：Behavior-Driven Development（行为驱动开发）：BDD 可以让项目成员（甚至是不懂编程的）使用自然语言来描述系统功能和业务逻辑，从而根据这些描述步骤进行系统自动化的测试

### JS

#### Object.is

判断两个值是否为同一个值,基础类型之间比对值，引用类型比对引用,+0 !== -0、Number.NaN == NaN

> === 会将+0 == -0,Number.NaN !== NaN

```js
Object.is(0, -0); // false
Object.is(0, +0); // true
Object.is(-0, -0); // true
Object.is(NaN, 0 / 0); // true
```

### 编程

#### Mixin

使用场景：当想要在不同的类层次结构中多个类之间共享相同的行为时或者无法合适抽象出部分子类共同的行为到基类中时使用

作用：实现复用，解决了单继承，多接口实现中，多个类需要重复实现同样方法的痛点

> 有 A、B 两个类，IB 接口，C exteds A、D exteds A1、E exteds A2、F exteds A3，然后均实现了 IB 接口，但是 C、D、E、F 实现 IB 的的方法都是一样的而且在 B 类中有实现，在单继承体系中需要重复编写同样的代码

实现：

- dart: 仍然为单继承,编译时基于原有类及 mixin 生成多个中间类，然后继承,既然是继承，则具有多态特性
- 多继承

### 编码认知

#### 线上问题调查

日常开发 VS 问题调查
日常开发：更多的精力是会消耗在普通的 crud 逻辑，编译，部署等这些非核心点，对思维逻辑的提高帮助不大或锻炼性比较低
问题调查：不需要写任何代码，但是需要在很短时间内，让自己理清思路，按正确的步骤去查出代码的核心问题，底层系统的核心问题,强制去进行思考

人性
每个人都喜欢做省力的事情，喜欢的事情。但是人往往有偏见，根本没有想明白查线上问题的价值，就认为这是一个很 low 的事，是不可取的。对自己不了解的，未知的事物，应该敬畏和学习。

#### 面试

比起死记硬背做题，更需要考验独立解决问题的能力。

讲一个之前投入度比较高的项目，描述下自己是怎么独立去解决问题的。对每一个点的描述，只要你觉得还不能体现他“独立解决问题”的能力，那就继续扒皮深问，直到他竭尽全力，被你”逼到墙角”。特别优秀的人被逼到墙角后，具备现场把墙砸掉的能力

> CRM 查询慢/死锁 --> 读写不分离 --> 读写分离
> 问题库接口慢 --> 开发人员无法解决 --> 重写接口，自行解决

人性
懒：影响独立解决问题的意识。
要面子：拿公司制度掩盖自己无法独立解决问题的现状。

#### 线上故障原因

到底是什么原因，会导致严重的线上故障呢？是我们团队的技术水平不高，还是流程问题才造成了如此严重的故障呢？

> 个体的过失很难造成严重的线上故障。真正的原因是：集体性的认知出错

例：
个体认知出错：比起写代码，认为其他事情重要性不高，不重视，从而导致疏忽
集体认知错误：项目上线时未完成测试，有风险所以不上，这个时候不是赞同而是需要立即反思问题，为什么无法按期上线，避免大家逐渐形成有风险 === 不上线，从而变成延期的借口。

人性
盲目自信：对自己做的领域有天然的偏见，哪个重要，哪个不重要。
随大流：别人也这么做了，应该不会错，还省力，我也这么做。
懒：默守所谓的安全方案，其实在那个场景下已经不安全了，但是内心认知出现偏差，懒得去破局改进。

#### 如何看待代码逻辑复用

能力复用、业务不复用，不是任何代码都需要抽离复用

认知
不要刻舟求剑，妄图用一套规则来应对外部复杂变化的世界，要因地制宜，实事求是，学会变通。

#### 认知提高

##### 专心，不要关注太多无意义的事情

不要去想今天你学的语言明天是否还流行，先利用当前语言训练好你的思维模式。
不要去想我作为测试给开发指出太多问题后，开发会不会不爽，做为测试你的核心是保证产品质量。
不要去想今天我帮组内的开发分担了额外的代码编写，我是不是亏了，这些付出一定会在将来某个时候兑现，因为你比他们有更多的代码实践

##### 知识整合、联想

人类的大脑从来都是一个网状的，互相关联的知识图谱，根本不存在靠”单一事物”修炼成功的好吗。
千万不要成为技术上的孔乙己，天天学各种 API 的写法，和学习茴香豆的茴字有几种写法没有任何区别。
在方案想不出来的时候，在代码水平感觉到瓶颈的时候，在看不懂一些专业书籍的时候，一定要跳出来，和自己的兴趣结合，和自己经历结合，和自己的生活结合，这样才能突破瓶颈，提升到更上一层的认知。

##### 更高认知人的指引

科幻神作三体里，外星人看地球人就像纸片一样，在三体人的眼中，地球人是二维的，而不是三维的。回到现实中，高认知的人看低认知的人也是一样的，不是低认知的人不够努力，而是你的知识图谱里比高认知的人少了一些维度。所以不管你怎么努力，你会发现仍旧无法超过他，他还比你轻松，学霸给大家留下的阴影就是这么来的。
在实际工作中，你的 leader，你的架构师只要不是水货，往往他们的认知就是比你高的。一旦你觉得这个人的本性是靠谱的，你就该无条件去相信他给你的建议和指引。因为他能看到在你那个维度上感受不到的东西，照他的话去实践几次，你才有机会到达他那个维度，才能升级认知。不过在现实情况中，我们往往看到很多 leader 和架构给下面的同学苦口婆心说了很多，但是他们不理解，反而更叛逆。

##### 持之以恒

越是辛苦的实践，越是坚持，你最后的收获一定越大,认知不通过持之以恒的实践是不可能升级
实践应该尽量和公司的项目去结合，而不是依靠于自己写 demo(写 demo 没有明确的目的和目标)

## 12

### Web

#### Svelte

**特点**

- 无运行时
- Template（类 vue），通过编译预处理来进行优化，代码生成
- 位掩码记录是否需要更新组件

**位掩码**

代码编译后，会根据模板引用的变量和依赖

- 更新变量的代码追加代码,mark_dirty()，更新脏记录数组中的 0/1
- 生成 if(xxx) { update(dom) } 的代码

脏记录数组，每个项都是 31 位的二进制字符串(js 最大数字),每一位二进制元素都关联了 template 中需要更新 dom 节点，统一通过微任务的方式，layout, repaint 的阶段后进行更新

### CSS

#### display

display: contents 的元素本身不会被渲染，但是其子元素能够正常被渲染

- 充当无语义的包裹框
- 让代码更加符合语义化

```html
<!--  不想要button的样式和行为，自己进行控制，但单纯的p标签会导致语义化降低  -->
<p class="button">
  <button style="display: contents">Button</button>
</p>
<p class="button">
  <button style="display: contents">Click Me</button>
</p>
```

- 对于一些常见的可替换元素、表单元素,相当于 display: none

#### 字体

- 基线：书写英语字母时，字母 X 底部所在的位置
- 行高( line-height )：两行文字基线之间的距离
- content area : 围绕文字看不见的 Box，其大小与 font-size 有关，修改 font-size 实际是对这款区域大小的修改?
- inline boxes: 不会成块显示，而是并排显示在一行的 boxes ，如 span,a,em 等标签以及匿名 inline boxes（即不含把标签的裸露的文字）
- line boxes: 由一个一个的 inline boxes 组成，一行即为一个 line box
- containing box: 外层盒子模型,包含了其他的 boxes

**vertical-align**

起作用的前提：元素为 inline 水平元素或 table-cell 元素，包括 span , img , input , button , td 以及通过 display 改变了显示水平为 inline 水平或者 table-cell 的元素。这也意味着，默认情况下， div , p 等元素设置 vertical-align 无效

> float 和 position: absolute ，一旦设置了这两个属性之一，元素的 display 值被忽略，强制当成 block 方式处理，因此，vertical-align 也就失去了作用

- baseline: vertical-align 的默认值，其意思是指基线对齐,可以把每一个行框盒子的后面想象有一个看不见的节点 x 元素就是和这个字母 x 的下边缘对齐
- top 与 bottom: 元素的顶部（底部）和当前行框盒子的顶部（底部）对齐；即与 line-box 的顶部（底部）对齐 对于 table-cell 元素，指的是元素的顶 padding 边缘和表格行的顶部对齐
- middle:元素的垂直中心点与行框盒子基线往上 1/2x-height 处对齐,就是字母 X 的中心位置对齐
- text-top: 盒子的顶部和父级内容区域的顶部对齐，即与 content-area 顶部对齐

### JS

#### Array

- push 的内部逻辑就是先给下标赋值，然后设置 length,触发 set
  > 第一次为插入元素
  > 第二次为 length 修改，但 length 已经是新值了
- shift 或 unshift,如果数组长度是 N，shift|unshift 就会触发 N set
  > 往前插入、删除一个，全部元素往前挪
- splice 同样会产生多次
  > 会产生元素索引挪动

影响: proxy 代理时会触发多次 set,push 可通过判断 length 来避免,shift 等（Vue 不解决，而是通过批量渲染来保证最终不会渲染多次）

## 13

### JS

#### Collection

- Map|Set:内部存储的数据必须通过 this 来访问，无法被 Proxy 代理 set 操作,需要通过 get 代理进行 bind 绑定后才能进行 set
- Array: 由于历史原因，数组不会有 Map|Set 的问题

#### Flutter

##### 动画

**动画曲线**

SpringSimulation: 弹簧

**隐式动画**

使用 Flutter 框架内置的动画部件创建，通过设置动画的起始值和最终值来触发

- AnimatedOpacity: 通过 opacity 控制组件显示、隐藏

**显式动画**

指的是需要手动设置动画的时间，运动曲线，取值范围的动画

- RotationTransition
- FadeTransition
- ScaleTransition
- SizeTransition
- SlideTransition

**Hero 动画**

在页面切换时一个元素从旧页面运动到新页面的动画。Hero 动画需要使用两个 Hero 控件实现：一个用来在旧页面中，另一个在新页面。两个 Hero 控件需要使用相同的 tag 属性，并且不能与其他 tag 重复

- Hero

**交织动画**

由一系列的小动画组成的动画。每个小动画可以是连续或间断的，也可以相互重叠。其关键点在于使用 Interval 部件给每个小动画设置一个时间间隔，以及为每个动画的设置一个取值范围 Tween，最后使用一个 AnimationController 控制总体的动画状态

### git

#### .git 文件

##### Hooks

hook 配置文件

##### COMMIT_EDITMSG

本地最后一个提交的信息

##### packed-refs

clone 仓库时所有的引用

##### objects

文件夹下先以对象哈希前两位划分文件夹再存放对象

- 系统对同一层级目录下文件数量有限制，用两位 16 进制划分，限制了文件夹只能有 256 个
- 性能问题？作为索引或分页依据？

#### 使用技巧

**只合并部分代码**

避免需要处理自己改动外的冲突，只合并自己熟悉的部分

git pull origin dev --> 存在大量 conflict --> git reset --hard(回滚 merge)
--> git checkout -b dev-backup(备份当前修改) --> git checkout dev
--> git reset --hard origin/dev(分支之间使用远程的，放弃此分支本地所有 commit)
--> git checkout dev-backup pages/xxxx(将 dev-backup 分支上的 xxx 目录下或者 xxx 文件的代码单独合并到 dev)

## 14

### Webpack

监听本地文件的变化主要是通过文件的生成时间是否有变化

#### 热更新

原理：webpack 模块都是缓存在 module 对象中，热更新则是将旧的 value 删除然后以新的值替换

- 热更新代码请求：通过 jsonp 请求 js 获取 js 代码，然后创建 script 标签执行
- 调用全局方法 webpackHotUpdate，移除缓存中的过期模块，存储新模块
- 通过**webpack_require**执行新的模块代码

## 16

### CORB

#### 概述

Cross-Origin Read Blocking，是一种判断是否要在跨站资源数据到达页面之前阻断其到达当前站点进程中的算法，降低了敏感数据暴露的风险。

响应结果会被置空，但是请求的服务仍然成功，`status: 200`。比如：使用 `img` 标签上报页面监控数据，尽管响应结果为空，但请求依旧发送成功，服务器亦正常响应

#### 原因

##### 旁路攻击（side-channel attacks）

**概述**

在你的程序正常通讯通道之外，产生了一种边缘特征，这些特征反映了你不想产生的信息，这个信息被人拿到了，你就泄密了。这个边缘特征产生的信息通道，就叫旁路，利用程序运行的物理特征来推测进行攻击

假设访问一个变量，这个变量在内存中，这需要上百个时钟周期才能完成，但如果变量访问过一次，这个变量被加载到缓冲（Cache）中了，下次再访问，可能几个时钟周期就可以完成了，可根据这种访问速度窃取特定数据，Spectre 和 Meltdown 漏洞便是利用了这种特性

理想示例

账号:root 密码:123456

输入密码:1111 错误，时间为 x
...
输入密码:12456 错误，时间为 x + ?

逐渐根据时长来推断出正确密码

**攻击方式**

- Spectre
- Meltdown

#### 应对

为了防止恶意站点的代码和正常站点运行在同一块内存空间中，怕通过根据访问内存的速度来推断出信息？
1、通过 Site Isolation，对于不同域名产生新的线程来运行（只要一级域名一样就共享？）
2、在同源策略 + 线程隔离后，由于 script 等跨域标签仍存在风险，CORB 就在这时候体现，会先响应内容置空 > 如果 CORB 不拦截，请求会成功然后将请求信息留存到内存中，这个信息可能存在被盗用风险

#### 作用时机

当跨域请求回来的数据 MIME type 同跨域标签应有的 MIME 类型不匹配时，浏览器会启动 CORB 保护数据不被泄漏，被保护的数据类型只有`html`、`xml` 和 `json`(即跨域标签的响应是这几种类型时会触发)。很明显 `<script>` 和 `<img>` 等跨域标签应有的 MIME type 和 html、xml、json 不一样

在满足跨域标签（如：<script>，<img>）请求的响应内容的 MIME type 是 HTML MIME type 、 XML MIME type、JSON MIME type 和 text/plain 时，以下三个条件任何一个满足，就享受 CORB 保护

- 响应头包含 X-Content-Type-Options: nosniff（禁用嗅探,此时内容属于有危险，被 block）
- 响应结果状态码是 206 Partial Content （developer.mozilla.org/zh-CN/docs/…
- 浏览器嗅探响应内容的 MIME 类型结果就是 json/xml/html（经嗅探后确实是危险内容，block）

**如果使用 script 跨域请求本就是 js 资源，但该资源却被打上了错误的 Content-Type，还添加了 nosiniff，会发生什么？**

GG

**多出来的 text/plain**

据可靠数据显示（可靠数据??）， HTML, JSON, or XML 有时候也会被标记为 text/palin？服务器响应不规范？？

**MIME**

Multipurpose Internet Mail Extensions，互联网标准，扩展了电子邮件标准，使其可以支持更多的消息类型。

常见 MIME 类型如：text/html text/plain image/png application/javascript ，用于标识返回消息属于哪一种文档类型。写法为 type/subtype。

在 HTTP 请求的响应头中，以 Content-Type: application/javascript; charset=UTF-8 的形式出现，MIME type 是 Content-Type 值的一部分

**内容嗅探技术（MIME sniffing）**

响应头没有指明 MIME type 或 浏览器认为指定类型有误时，浏览器会对响应内容资源进行检查并执行，来猜测内容的正确 MIME 类型

禁用：服务器在响应首部添加 X-Content-Type-Options: nosniff，用来告诉浏览器一定要相信 Content-Type 中指定的 MIME 类型，不要再使用内容嗅探技术探测响应内容类型。该方法仅对 `<script>` 和 `<style>` 有效

### 浏览器

Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个渲染线程，GUI 渲染和 Javascript 执行 两者是互斥的. 另外异步 I/O 操作底层实际上可能是多线程的在驱动

### 前端框架

为了防止浏览器长任务卡住界面

方法有三个
1️⃣ 优化每个任务，让它有多快就多快。挤压 CPU 运算量
    > vue通过模板编译来极致优化
2️⃣ 快速响应用户，让用户觉得够快，不能阻塞用户的交互
    > react通过fiber，让任务切片执行
3️⃣ 尝试 Worker 多线程
    > 有人尝试，但要保证状态和视图的一致性相当麻烦

#### React

##### 时间切片

利用MessageChannel和requestAnimationFrame组合来实现，在渲染结束后进行切片任务

1、requestAnimationFrame参数可以取到总的时间
2、分别在requestAnimationFrame和MessageChannel记录时间戳，对比可得出requestAnimationFrame到渲染结束耗时
3、结合上述两个时间，检查是否有任务被饿死（长时间未执行），检查是否仍有空闲，执行其他任务

##### 事件优先级

Immediate(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断
UserBlocking(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈
Normal (5s) 应对哪些不需要立即感受到的任务，例如网络请求
Low (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知
Idle (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死

### JS

#### DOM

##### 字符串转DOM

**Range**

script脚本会执行，使用时候需要注意

```js
let elements = document.createRange().createContextualFragment(html).children;
```

**innerHTML**

**insertAdjacentHTML**

**DOMParser**

- HTML字符串、XML字符串，SVG字符串解析
- 反转义html(已转移的html字符串反转义)
- script脚本不会执行
- 性能最差

```js
new DOMParser().parseFromString(html, 'text/html').body.childNodes;
```

### 数据库

#### 索引

**索引类型**

聚集索引，叶子节点存储行记录
普通索引，叶子节点存储PK值，即id（需要回表来查询到具体数据）

**回表**

有个主键为ID的索引，和一个普通name字段的索引，我们在普通字段上搜索：
select * from table where name = 'xx'
执行的流程是先查询到name索引上的“xx”，然后找到他的id是2，最后去主键索引，找到id为2对应的值。回到主键索引树搜索的过程，就是回表


**避免回表**

覆盖索引
只需要在一棵索引树上就能获取SQL所需的所有列数据，通过联合索引把需要的数据都包含

**B+树中一个节点到底多大合适？**

B+树中一个节点为一页或页的倍数最为合适

因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费。
如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费。
所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适。

**最左匹配原则**

索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引。
如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。
因此，列的排列顺序决定了可命中索引的列数。

例子：

如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)

## 17

### React

如果你的function会作为props传递给子组件，请一定要使用 useCallback 包裹，对于子组件来说，如果每次render都会导致你传递的函数发生变化，可能会对它造成非常大的困扰。同时也不利于react做渲染优化。

### Serverless

#### 冷启动

**基于上下文保持**

由于环境在启动后会被复用一定的时间，通过以下方式可保持Serverless的响应速度和资源的减少占用

- 每个一定时间调用一次函数（放弃第一次的调用，单纯作为冷启动）
- 利用环境保留，将一些变量全局或缓存（数据库连接等）,保证在只在冷启动时初始化一次,后面复用环境时即可复用

## 18

### UI

**留白**

内容和边缘预留padding，防止内容紧贴边缘导致的不美观
> 文章内容与背景边缘间留存空间

**对齐**

空间上不同位置的元素，应尽量在各个方向上对齐（具体情况具体分析）
> 避免页面上存在3个元素，1左一点、2右一点....

**对比度**

色彩部分内容，具有良好对比度的页面（如下面的页面）不仅看起来更好，而且更加用户友好和具有高可访问性，更好的突出重要内容;
WCAG（Web内容可访问性指南）建议最小（AA）对比度至少为 4.5:1，对于大文本，则为 3:1，或者增强（AAA）对比度为 7:1 或 4.5:1（大文本）
> 可通过工具辅助处理

**比例**

页面元素与整体页面间比例、留白空间、内容占据大小

**版式**

字体选择、字体大小、对齐方式、字母间距、行高、字体样式、颜色和对比度等，字体排版

**颜色**

不同颜色之间的匹配、搭配、突出，适当的根据颜色隐含的含义做出不同引导


**视觉层次**


不同区块的元素通过位置、对比度、颜色、比例、样式或以上各项的组合来完成此操作，建立好的视觉层次对用户更加友好

## 19

### Source map

source-map: 生成单独的source map 文件，js中附带定位,可定位原始代码
eval: 不生成source map 文件，内容通过eval全包含在js文件中，可自行对压缩后代码进行定位，自行定位压缩后代码
hidden-source-map: 生成sourcemap文件，js中不附带定位，浏览器无法自动找出source map进行映射，需自行进行映射，可定位原始代码
inline-source-map: 不生成source map 文件,内容包含在js文件中，但会经过Base64编码，可定位原始代码
eval-source-map: 不生成source map 文件，内容通过eval全包含在js文件中,并且eval的内容会经过Base64编码，可定位原始代码
cheap-source-map: 生成sourcemap文件，但通过sourceMap无法定位代码位置，自行定位压缩后代码？

[官方推荐](https://webpack.js.org/configuration/devtool/#special-cases)
> 生产环境: source-map(完整，但不允许外部访问)、hidden-source-map、none

### JS

#### 异常类型

##### JS内置异常

**异常类型**

- SyntaxError（语法错误）
- ReferenceError（引用错误）
- RangeError（范围错误）
- TypeError（类型错误）
- URLError（URL错误）
- EvalError（eval错误）

**捕获方式**

- onerror: 会被覆盖，弃用
- addEventListener: 存在兼容性问题，结合attachEvent一起使用
- attachEvent: ie8前使用，监听时需增加on前缀

##### Promise未处理异常

window.onunhandledrejection

**注意**

如果一个Promise错误最初未被处理，但是稍后又得到了处理，则会触发rejectionhandled事件。因此最好在监听到unhandledrejection事件时，不要立刻触发上报，可以选择等待一定时间(settimeout)，监听是否被处理了，到时再进行上报处理。尤其在混合开发的时候容易遇到
> 监听rejectionhandled判断事件是否真的被处理，然后再上报，已处理则取消上报


##### 资源加载异常

img、script里的src和link标签里的href属性存在时，会请求对应的资源。如果错误资源报错，该标签会触发error事件，执行DOM的onerror方法，但并不会冒泡到全局，需对元素进行onerror监听

坑:使用onerror事件去获取一个默认地址的图片,如果刚好onerror去获取的图片也不在，那么就会一直触发onerror事件，这个标签一直在请求一个不存在的图片。也就是会一直循环请求

##### 网络请求异常

XMLHttpRequest、fetch

重写内置对象，对对象的事件进行重写从而实现请求时各个阶段的监听

### VSCode

#### 快捷键

Ctrl + D 添加选中下一个匹配项
Ctrl + U 回退选中下一个匹配项
Ctrl + shift + k 删除当前行 

### TS

#### Type vs interface

type: 可以进行 | 枚举
interface: 可重复声明来追加属性


## 21

### TS

#### React Class props state

```ts
const defaultProps = {
    name: 'FrontDream',
    age: 18
}

const initState = {
    content: ''
}
type StateProps = Readonly<typeof initState>
type DefaultProps = Readonly<typeof defaultProps>

// 设置默认prop、state，利用类型推断，同时提高容错
```

### URI

URI: Uniform Resource Identifier 统一资源标示符，标识一个资源
URL:Uniform Resource Location 统一资源定位符，提供找到资源的路径
URN: Universal Resource Name   统一资源名称，用特定命名空间的名字标识资源
URL和URN都是URI的子集

#### URL

url格式标准为:  scheme://host.domain:port/path/filename

scheme:定义因特网服务的类型。最常见的类型有 http，https，ftp、file
host：定义域主机（http 的默认主机是 www）
domain - 定义因特网域名，比如 baidu.com
port - 定义主机上的端口号（http 的默认端口号是 80）
path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）
filename - 定义文档/资源的名称

### HTTP

#### 三次握手

1、发送 --> 接收 接收方 知道 发送方的发送能力、接收方的接收能力正常  
2、接收 --> 发送 发送方 知道 接收方的发送能力、发送方的接收能力正常
3、发送 --> 接收 接收方 知道 发送方确认，双方能力都正常

防止旧的重复连接初始化造成混乱

#### 四次挥手

1、发送 --> 接收  要关闭连接
2、接收 --> 发送  知道了（此时数据可能未接收完毕）
3、接收 --> 发送  要关闭了（数据接收完毕）
4、发送 --> 接收  确认关闭,发送后等待2MSL（两个发送周期），防止确认丢失（服务器收不到会重发3），然后再关闭连接

### Canvas

save、restore，存储/弹出画布状态，处理的不是画布内容，而是画布的绘制属性（即画笔设置）