### 1

#### 开车

右车道          才是自己的车道         对面有车来要让或打转向灯

#### 反省

为人处世上，emmmm，但是我

#### Docker

##### 网络

默认的bridge不支持DNS解析

docker network create --driver bridge briName
> 创建自定义的bridge

docker run --network briName
> 将容器挂载到特定bri上

##### 容器无法联网（ping不通ip）

sudo apt-get install bridge-utils -y
sudo service docker stop
sudo ip link set dev docker0 down  / sudo brctl delbr docker0(新系统被废弃) ? 
sudo service docker start
docker network inspect bridge


### 2

#### docker

sudo docker run  -d -p 8080:80 -p 8081:9090 
-it --network bri_dns 
--privileged  
--name yapi 
-v /usr/local/source:/usr/local/source 
centos 
/usr/sbin/init
> privileged 给容器提供更高权限,可以使用systemctl

https://www.cnblogs.com/architectforest/p/12389218.html


### 4

#### centos

##### service: command not found

yum list | grep initscripts

yum install initscripts -y

##### mongodb

###### 安装

touch /etc/yum.repos.d/mongodb-org-4.2.repo

vi /etc/yum.repos.d/mongodb-org-4.2.repo
```
[mongodb-org-4.2]
name=MongoDB Repository
baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/
gpgcheck=1
enabled=1
gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc
// $releasever 填系统版本？
```

yum install -y mongodb-org

systemctl start mongodb

systemctl status mongodb

systemctl enable mongodb // 永久启动

###### 配置文件

/etc/mongod.conf
> 将bindIp 注释掉开放远程访问

###### Failed to start mongod.service:until not found

touch /etc/systemd/system/mongodb.service

```
[Unit]

Description=High-performance, schema-free document-oriented database

After=network.target

[Service]

User=mongodb           

ExecStart=/usr/bin/mongod --quiet --config /etc/mongod.conf

[Install]

WantedBy=multi-user.target
// User=root 看登录的用户
```

#### yapi

##### docker

sudo docker run  -d -p 9090:9090 -p 9091:80 -p 9092:8080 -p 9093:8081 -p 9097:27017 -it --network bri_dns --privileged  --name yapi -v /usr/local/source:/usr/local/source centos /usr/sbin/init

sudo docker exec -it yapi /bin/bash

##### 内置

nodejs
yum install -y nodejs

git
yum install -y git

mongodb

service mongod start

yapi
npm install -g yapi-cli --registry https://registry.npm.taobao.org

yapi server 


### 5

#### Docker

docker login

##### images

docker commit -a "rq" -m "node + git" nodejs rquanx/nodejs:v1
> -a 作者信息
> -m 信息
> nodejs 容器名字
> 仓库路径？ v1: tag

docker push rquanx/nodejs:v1


##### 问题

ERROR: Couldn't connect to Docker daemon at http+docker://localunixsocket - is it running?
使用docker命令一直没有权限时


如果还没有 docker group 就添加一个：sudo groupadd docker

将用户加入该 group 内。然后退出并重新登录就生效啦：sudo gpasswd -a ${USER} docker

重启 docker 服务：sudo service docker restart

切换当前会话到新 group 或者重启 X 会话：newgrp - docker

### 10

#### SQL

##### case when

查询时
CASE column
      WHEN '长沙' THEN '湖南' 
      WHEN '衡阳' THEN '湖南'
      WHEN '海口' THEN '海南' 
      WHEN '三亚' THEN '海南'
    ELSE '其他' as columnAlias
> 对特定列的值进行处理


更新时，根据数据进行不同的更新处理
UPDATE Salaries
SET salary = 
CASE 
    WHEN salary >= 10000 THEN salary * 0.9
    WHEN salary < 10000 THEN salary * 1.2
    ELSE salary END;

##### 性能优化

###### 避免子查询

参数是子查询时，使用 EXISTS 代替 IN
```sql
-- 慢
SELECT * 
  FROM Class_A
WHERE id IN (SELECT id 
               FROM  CLASS_B);

-- 快
SELECT *
  FROM Class_A A 
 WHERE EXISTS
(SELECT * 
   FROM Class_B  B
  WHERE A.id = B.id);
```

可以用到索引，如果连接列 (id) 上建立了索引，那么查询 Class_B 时不用查实际的表，只需查索引就可以了。(子查询用不到索引？)

如果使用 EXISTS，那么只要查到一行数据满足条件就会终止查询， 不用像使用 IN 时一样扫描全表。在这一点上 NOT EXISTS 也一样


如果 IN 后面如果跟着的是子查询，由于 SQL 会先执行 IN 后面的子查询，会将子查询的结果保存在一张临时的工作表里（内联视图），然后扫描整个视图，显然扫描整个视图这个工作很多时候是非常耗时的，而用 EXISTS 不会生成临时表


##### 排序

会产生排序的语句

GROUP BY 子句
ORDER BY 子句
聚合函数(SUM、COUNT、AVG、MAX、MIN)
DISTINCT
集合运算符(UNION、INTERSECT、EXCEPT)
窗口函数(RANK、ROW_NUMBER 等)

如果在内存中排序还好，但如果内存不够导致需要在硬盘上排序上的话，性能就会急剧下降
> 数据量大时会出现问题


##### 无法使用索引

<>
!=
NOT IN
产生类型转换也会让索引失效
> 例对char类型使用number值作条件
子查询的结果会产生一张新表，不过如果不加限制大量使用中间表的话，会带来两个问题，一是展示数据需要消耗内存资源，二是原始表中的索引不容易用到

### 15

#### Nodejs

执行child_process.exec报错maxBuffer exceeded
> options. stdio 设置有关, child_process.exec(x,{maxBuffer: 111},cb);

child_process.spawn 方法调用shell脚本发现控制台无法监听用户的输入
> options. stdio 设置有关

nodejs 调用 shell 后，shell里面的命令找不到
> options.env有关

### 17

#### HTTP

##### 历史

0.9
只能get,不支持请求头

1.0

1.1
支持连接复用、分块发送

SPDY

HTTP2前身

QUIC

基于UDP实现TCP + HTTP2

HTTP2

多路复用、头部压缩

HTTP3

QUIC更名来


##### keep-alive

目的：为了解决性能问题而产生的

达成：当客户端请求中含有Connection: Keep-Alive首部，服务器响应中也有Connection: Keep-Alive首部时，双方才会成功建立持久连接

版本：1.0才需要设置，1.1时默认为长连接


当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接


浏览器：从HTTP/1.1起，浏览器默认都开启了Keep-Alive
客户端、服务器：都能选择随时关闭连接，则请求头中为connection:close

#### 心理

##### 常态偏差
人们倾向于相信事物将会以正常的方式运行，不太可能出现不正常的情况，从而低估了灾难的可能性和影响程度。

#### C#

##### 内存泄漏

1、Event订阅
A类劫持了B类的函数，且A类生命周期较长，会造成A无法释放

解决

- 注销订阅事件
- 使用弱句柄（weak-handler）模式，类似Weak map?
- 使用匿名函数进行订阅，并且不要捕获任何类成员

2、在匿名方法中捕获类成员
引用对象这个事情在匿名方法中捕获类成员

```c#
public class MyClass
{
    private JobQueue _jobQueue;
    private int _id;
 
    public MyClass(JobQueue jobQueue)
    {
        _jobQueue = jobQueue;
    }
 
    public void Foo()
    {
        _jobQueue.EnqueueJob(() =>
        {
            Logger.Log($"Executing job with ID {_id}");
            // do stuff 
        });

        // 解决
        var local = _id;
        // ... 
    }
}
```

解决
将值分配给局部变量，不会有任何内容被捕获，并且避免了潜在的内存泄漏

3、静态变量
静态变量不会被回收，如果静态变量是类似List，可以在运行时不断增加，但是不会被回收，可能会导致

4、缓存变量

5、不停止的线程

不停止的线程或引用启动它的类

6、Alloc
手动分配内存后，需手动释放或添加Dispose

7、添加Dispose无效
使用using() {}


#### 产品

[B端和C端产品设计有哪些差异](https://zhuanlan.zhihu.com/p/135403630)

#### SQL

##### 表

```sql
if Exists(select top 1 * from sysObjects where Id=OBJECT_ID('TableName') and xtype='U') 
-- 检查数据库表是否存在

select * from sysObjects where  xtype='U'
-- 查询所有的表？

-- sysObjects系统对象表（存储所有表？）
```

###### 表PROPERTIES

```sql
IF NOT EXISTS (
  SELECT
  NULL
  FROM
  SYS.EXTENDED_PROPERTIES
  WHERE
  [major_id] = OBJECT_ID('TableName')
  AND [name] = N'PROPERTIESName'
  AND [minor_id] = 0
)
-- 检查表是否存在属性

SELECT
  *
  FROM
  SYS.EXTENDED_PROPERTIES
  WHERE
  [major_id] = OBJECT_ID('TableName')
  AND [minor_id] = 0
-- 查询表所有的属性？

-- SYS.EXTENDED_PROPERTIES系统属性表？

```

存储过程

```sql

exec sys.sp_addextendedproperty 'PROPERTIESName','描述信息','SCHEMA','dbo','table','TableName';
-- 向表增加特定的属性字段，内容为描述信息

exec sys.sp_updateextendedproperty 'PROPERTIESName','描述信息','SCHEMA','dbo','table','TableName';
-- 更新表特定的属性字段，内容为描述信息

```


##### 列

```sql
IF EXISTS ( SELECT 1 FROM SYSOBJECTS T1 INNER JOIN SYSCOLUMNS T2 ON T1.ID=T2.ID    
  WHERE T1.NAME='TableName' AND T2.NAME='ColumnName')
-- 检查表是否存在特定列

SELECT 1 FROM SYSOBJECTS T1 INNER JOIN SYSCOLUMNS T2 ON T1.ID=T2.ID    
  WHERE T1.NAME='TableName'
-- 查询表所有的列

-- SYSCOLUMNS系统列表？

```

###### 列PROPERTIES

```sql
IF NOT EXISTS (
  SELECT
  NULL
  FROM
  SYS.EXTENDED_PROPERTIES
  WHERE
  [major_id] = OBJECT_ID('TableName')
  AND [name] = N'PROPERTIESName'
  AND [minor_id] = (
      SELECT
      [column_id]
      FROM
      SYS.COLUMNS
      WHERE
      [name] = 'ColumnName'
      AND [object_id] = OBJECT_ID('TableName')
  )
)
-- 检查特定表的特定列是否存在属性

SELECT [name] FROM SYS.COLUMNS WHERE
       [object_id] = OBJECT_ID('TableName')
-- 获取特定表的所有列

```

存储过程

```sql

 exec sys.sp_addextendedproperty 'PROPERTIESName','描述信息','SCHEMA',N'dbo','TABLE','TableName','COLUMN','ColumnName';
-- 向特定表的特定列增加属性

 exec sys.sp_updateextendedproperty 'PROPERTIESName','描述信息','SCHEMA','dbo','TABLE','TableName','COLUMN','ColumnName';

```