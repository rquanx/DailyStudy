### 2

#### C#

##### Records

##### 索引

Indexes 用于索引，例如使用 ^1 索引倒数第一个元素

使用：
1、内部维护一个数组属性，然后通过属性时是读取特定的属性
2、返回特定的计算值

```C#
// 按以下方式定义后，可以对变量进行索引访问
// 可以定义多个
<return type> this[<parameter type> index]
{
    get{
        //  自定义通过索引读取时操作
        // return the value from the specified index of an internal collection
    }
    set{
        // 自定义通过索引赋值时操作
        // set values at the specified index in an internal collection
    }
}

class StringDataStore
{
    private string[] strArr = new string[10]; // internal data storage

    public string this[int index]
    {
        get
        {
            if (index < 0 &&  index >= strArr.Length)
                throw new IndexOutOfRangeException("Index out of range");

                return strArr[index];
        }

        set
        {
            if (index < 0 ||  index >= strArr.Length)
                throw new IndexOutOfRangeException("Index out of range");

            strArr[index] = value;
        }
    }
}

StringDataStore strStore = new StringDataStore();

strStore[0] = "One";
strStore[1] = "Two";
strStore[2] = "Three";
strStore[3] = "Four";
```

##### Range

Range
只要类可以被计数（拥有 Length 或 Count 属性），并且可以被切片（拥有一个 Slice(int, int) 方法），那么就可以用该特性

```C#
Range range = 1..4;  // 表示一个范围从索引为1的到索引为4的
string[] names = { "Archimedes", "Pythagoras", "Euclid", "Socrates", "Plato" };
foreach(var item in names[range]) {

}

foreach(var item in names[1..4]) {

}

// 两端均除去一个
foreach(var item in names[1..^1]) {

}
// [..] == [0..^0]  全部
// [1..] == [1..^0]  除去第一个
```


##### 类型实现解构

```C#
// 按此格式对类定义Deconstruct方法接口
class type
{
    private typeA A;
    private typeB B;
    public void Deconstruct(out typeA a, out typeB b)
    {
        a = A;
        b = B;
    }
}



class MyDeconstruct
{
    private int A => 1;
    private int B => 2;
    public void Deconstruct(out int a, out int b)
    {
        a = A;
        b = B;
    }
}
var x = new MyDeconstruct();
var (o, u) = x;
```

##### HelpPage

说明文档xml更新
1、项目属性设置-->生成-->生成的xml路径
2、将xml拷贝至app_data

### 4

#### 跨域

##### URI结构

[协议名]://[用户名]:[密码]@[主机名]:[端口]/[路径]?[查询参数]#[片段ID]

##### 同源

协议、主机名(host)以及端口三者均相同
> 主域和子域视为不同、域名与其对应的IP也视为不同
> 看着必须一样

##### 限制

Cookie、LocalStorage 和 IndexDB 无法读取。

DOM 无法获得。

AJAX 请求被拦截

##### CORS 跨域资源共享

（Cross-origin resource sharing）

###### 简单请求

什么是简单请求
> 普通 HTML Form 在不依赖脚本的情况下可以发出的请求

特征
> 三种请求方式之一：HEAD、GET、POST
> Header信息不超出以下几种字段
> Accept
> Accept-Language
> Content-Language
> Last-Event-ID
> Content-Type：application/x-www-form-urlencoded、 multipart/form-data、text/plain
> DPR
> Downlink
> Save-Data
> Viewport-Width
> Width

过程

1、浏览器发送
浏览器会在Request Header中添加 Origin （协议 + 域名 + 端口）字段 ， 它表示我们的请求源，CORS服务端会将该字段作为跨源标志

2、服务器处理
接收到此次请求后 ， 首先会判断Origin是否在允许源（由服务端决定,Access-Control-Allow-Origin）范围之内，然后在Response Header 添加 Access-Control-Allow-Origin、Access-Control-Allow-Credentials等字段
> 必须字段：
> Access-Control-Allow-Origin
> 表示服务端允许的请求源，*标识任何外域，多个源 , 分隔,浏览器接收响应后会用来校验
>
> 可选字段
> Access-Control-Allow-Credentials：false
> 表示是否允许发送Cookie，设置为true,同时，ajax请求设置withCredentials = true,浏览器的cookie就能发送到服务端
>
> Access-Control-Expose-Headers
> 调用getResponseHeader（）方法时候，能从header中获取的参数

3、浏览器接收
> 浏览器收到Respnose后会判断自己的源是否存在 Access-Control-Allow-Origin允许源中，如果不存在，会抛出“同源检测异常”

###### 预检请求

> 什么是预检请求
> 为什么有预检请求
> 预检请求作用
> OPTIONS方法发起一个预检请求(preflight request)

###### 复杂请求

> 普通 HTML Form 无法实现的请求
> 先发生预检请求，供服务器校验
> 浏览器先单独请求一次，询问服务器某个资源是否可以跨源，如果不允许的话就不发实际的请求,如果允许的话，浏览器会记住，然后发实际请求，且之后每次就都直接请求而不用再询问服务器否可以跨源了。

##### 为什么要有简单请求、复杂请求

1、默认禁止跨源请求
许多服务器压根没打算给跨源用。当然你不给 CORS 响应头，浏览器也不会使用响应结果，但是请求本身可能已经造成了后果。所以最好是默认禁止跨源请求。
2、回答请求是否接受跨域总是要计算的，所以希望最好不用每次请求都让服务器劳神计算，从而有预检机制
3、简单请求是为了兼容普通表单发送请求和不为了加入CORS机制，从而将系统复杂化，没必要加
> 兼容的前提下发 preflight 对绝大多数服务器应用来说没有意义，反而把问题搞复杂
4、普通表单请求不经过CROS?
5、节省服务器计算
6、为了安全考虑，由于服务器api并不会对调用拦截，只要api开放了，就可以被随意调用，所有浏览器通过CORS来block掉请求
> 如果浏览器没有CORS，则请求会直接发出去
> 是浏览器自身为了安全考虑增加的

#### js

##### 字符串

在 JavaScript 中，字符串值是一个由零或多个 Unicode 字符（字母、数字和其他字符）组成的序列。

字符串中的每个字符均可由一个转义序列表示。比如字母 a，也可以用转义序列 \u0061 表示

##### 执行字符串代码

1、eval 
2、new Function


###### 正则

如果在数量词 *、+、? 或 {}, 任意一个后面紧跟该符号（?），会使数量词变为非贪婪（ non-greedy） ，即匹配次数最小化
```js
// 尽量匹配多的a进行替换
console.log("aaabc".replace(/a+/g, "d")); // dbc

// 匹配少的a进行替换
console.log("aaabc".replace(/a+?/g, "d")); // dddbc
```

#### DSL

DSL 即「Domain Specific Language」，中文一般译为「领域特定语言」，在《领域特定语言》
[前端 DSL 实践指南](https://zhuanlan.zhihu.com/p/107947462)

##### 外部DSL

一种独立的编程语言，需要从解析器开始实现自己的编译工具，实现成本较高。但它的语法的灵活性更高，更容易达到用户的表现力需求。

外部 DSL 的直接对应就是 GPPL，由于受限语法特性更少，一般不要求图灵完备，所以它实现难度会低于 GPPL。
> GPPL 即 「General Purpose Programming Language」，又称通用编程语言，例如我们常用的 JavaScript，它们被设计用来解决通用编程问题
> Sass、React、Vue 支持的 JSX 语法都属于外部 DSL

##### 内部DSL

Embedded DSL or Internal DSL，是建立在其它宿主语言之上（一般为 GPPL）的特殊 DSL，它与宿主语言共享编译与调试工具等基础设施，学习成本更低，也更容易被集成。
> 内部 DSL 的语法灵活度和语法噪音（syntactic noise）往往取决于宿主语言的选择
> 基于特定语言进行封装，如JQ

别名：流畅接口
> 属于接口封装或库封装的一种模式，目标是极限表达力
> 设计的首要目标是「极限流畅的表现力」，而非职责清晰、降低耦合度等传统的封装抽象准则

###### 常见风格(JS)

####### 级联
调用不再设计特定返回值，而是直接返回下一个上下文（通常是自身）

级联方法
> JQ

级联管道
> gulp
> .pipe().pipe()...

级联属性

链式嵌套函数
场景：生成xml / html
我的camlbuild，不太好
> 只能使用有限的api，不便于扩展
> 在层级抽象中需额外的 end() 出栈动作实现上下文切换
> 可读性强依赖于手动缩进，而编辑器的自动缩进往往会打破这种和谐

总结：无论是级联方法、级联管道还是级联属性，本质都是链式调用风格，链式调用的核心是上下文传递，所以每一次调用的返回实体是否符合用户的心智是 DSL 设计是否成功的重要依据。

####### 其他

嵌套函数
链式嵌套函数拆分成多个子函数，互相之间不关联，通过嵌套使用
> 优势：容易映射成外部DSL
> 缺点：不适合流程、时间等顺序敏感的场景

对象字面量
> js对象配置文件、json...
> 对象字面量的结构性较强，一般只用来做配置等数据抽象的场景，不适合用在过程抽象的场景

动态代理
内部 DSL 的构造方式有一个典型缺陷就是它们都是静态定义的属性或方法，没有动态性

内部 DSL 要实现这种特性，就强依赖宿主语言的元编程能力
> proxy
> 例：动态命名方法

Lambda 表达式
> linq

自然语言抽象
> 本质是一些语法糖
> chai、mocha、jest等
> 自动根据链式调用产生的状态，自动拼装出更友好的错误信息

### 6

#### 数学

##### 图片灰度转换算法

###### 应用

滤镜变灰
网站颜色变灰（css filter grayscale）

###### 原理

原色
> 指不能透过其他颜色的混合调配而得出的“基本色”。
> 一般来说叠加型的三原色是红色、绿色、蓝色，以不同比例将原色混合，可以产生出其他的新颜色。这套原色系统常被称为“RGB色彩空间”，亦即由红（R）绿（G）蓝（B）所组合出的色彩系统。

当这三种原色以等比例叠加在一起时，会变成灰色；若将此三原色的强度均调至最大并且等量重叠时，则会呈现白色。灰度就是没有色彩，RGB色彩分量全部相等。

###### 平均法

Gray = (Red + Green + Blue) / 3
> 优点：公式简单，所以易于维护和优化
> 缺点：灰度阴影和亮度方面做的还不够好

###### 基于人眼感知

根据人眼对颜色的感知程度进行参数调整。

考虑到了人眼对不同光感知程度不同。人的眼睛内有几种辨别颜色的锥形感光细胞，分别对黄绿色、绿色和蓝紫色的光最敏感。
人类对红绿蓝三色的感知程度依次是： 绿>红>蓝

Gray = (Red *0.3 + Green * 0.59 + Blue* 0.11)
Gray = (Red *0.2126 + Green * 0.7152 + Blue* 0.0722)
Gray = (Red *0.299 + Green * 0.587 + Blue* 0.114)

###### 去饱和

使用HLS模型

分别是：Hue(色调)、Saturation(饱和度)、Lightness(亮度)。

色调，取值为：0 - 360，0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。
饱和度，取值为：0.0% - 100.0%，它通常指颜色的鲜艳程度。
亮度，取值为：0.0% - 100.0%，黑色的亮度为0

Gray = ( Math.max(Red, Green, Blue) + Math.min(Red, Green, Blue) ) / 2
> 把RGB转换为HLS，然后将饱和度设为0
> 图片立体感减弱，但是更柔和

###### 分解

Gray = Math.max(Red, Green, Blue)
Gray = Math.min(Red, Green, Blue)
> 均只取最大值或最小值

###### 单一通道

不作计算，直接去单一颜色的值
Gray = Red / Green / Blue
> 大多数数码相机都用这个算法生成灰度图片。很难预测这种转换的结果，所以这种算法多用于艺术效果

###### 自定义灰度阴影

用户提供一个灰色阴影值，值的范围在2-256。2的结果是一张全白的图片，256的结果和平均法一样

ConversionFactor = 255 / (NumberOfShades - 1)
AverageValue = (Red + Green + Blue) / 3
Gray = Math.round((AverageValue / ConversionFactor) + 0.5) * ConversionFactor

#### TS

##### tsconfig

paths属性
> import提示时会按顺序进行匹配