### 4

#### C#

#### Webconfig
SP WebServices 操作DocX   本质是读取注册表时，出现权限问题

[removing identity impersonate="true" from the Web.Config file](https://stackoverflow.com/questions/43484379/closedxml-securityexception-requested-registry-access-is-not-allowed)

#### windows服务

windows服务 安装/卸载时，不要打开 service.msc

### 5

#### C# 

##### 动态载入DLL

```js
//载入dll中的函数
            //Assembly asm = Assembly.Load(strDllPath);//载入当前根文件夹的dll
            Assembly asm = Assembly.LoadFile(@"F:\WorkSpace\VS測试代码\反射測试001\反射message方法\reflect\reflect\bin\Debug\reflect.dll");//依据dll文件实际路径载入
            //用类型的命名空间和类获得类型
            System.Type FromClass = asm.GetType("reflect.Form1");
            //须要实例化类型,才干够使用,參数能够人为的指定,也能够无參数,静态实例能够省略
            Object obj = System.Activator.CreateInstance(FromClass);
            //通过方法名称获得方法(调试走到以下这一步的时候，就能够弹出“动态载入Dll測试”这个消息了)
            MethodInfo method = FromClass.GetMethod("TestReflect");
            //获取TestReflect函数的返回值，在这里会获取到"TestReflect返回值"，假设没有返回值，能够省略这一步
            object o = method.Invoke(obj, new object[] { });

```

#### 业务

##### ToB

[做To B，一定要避免的9类致命错误](https://mp.weixin.qq.com/s/G2BRzDjR4rpUkyyxR-hcRw)

- 不仅有售前、售中，还有售后，售后服务持续收费
- 需求更需要深挖
- 决策人和使用人的信息不对称：业务管理、领导和基层员工，中高层和底层存在误差，且中高层使用频率较低，所以提供的需求不一定对基层人员是好的
- 企业发展周期长
- 产品化、标准化: 需求大都是定制化的，容易陷入到大量的项目中变成项目制公司，难以规模化，如何用标准化产品满足碎片化需求

> 解决客户的问题，能用产品解决，就不要用服务解决，能用服务解决就不用咨询解决。咨询工作尽量服务化，服务工作尽量产品化。因为一旦你的模式越来越依赖于高阶的人力，企业一定很难规模化。
> 标准化不仅仅要体现在产品上，还要体现在销售上：一名真正好的销售，不仅仅要能把产品卖出去，让客户买一个很大的单。而是还要能够说服客户，在前期放弃或者推迟一些个性化需求。

- 销售和产品能力互补，销售能力不能太差，需要客户需求和客户服务为第一导向，甚至销售会稍微重要，To B创业公司CEO的画像——行业老炮+超级销售
- To B是价值敏感，To C是价格敏感，客户对价值的需要优先于价格
- 团队建设和组织能力的打造,需要做好产品、还需要多部门协同配合来完成

> To C的用户需求相对标准化，3~5个人的小团队如果能切准用户需求，就有机会做出爆款,价值链比较短，通过产品就能完成用户价值的交付，因此团队就可以比较轻，对组织能力的要求相对而言没有那么高

- 大客户和小客户

> 大的客户，客户方有钱，信誉比较高，可能拖一点账期，但不会不给你，同时对你的品牌有帮助，但是大客户难在个性化需求太多
> 小客户产品标准化程度高，没有个性化定制，但付费能力较弱，要降低获客成本

- 当产品足够通用、足够标准化、足够独立，同时还非常轻，也可以获得ToC产品一样的快速增长

> ToB产品ToC的难点：获客周期、实施成本、企业内部数据、内部流程的对接、个性化需求

#### 前端

##### 代码混淆

[前端代码混淆](<https://segmentfault.com/a/1190000019423501>)

###### AST混淆

变量名混淆

- 变量重名为短名称
- 混入16进制，增加混淆程度

> eval混淆（非静态代码分析）会有一定难度
> 作为输出的全局变量，为确保可用，需进行保护防止被混淆

常量提取

- 将常量混入到数组、二维数组、三维数组中，只要确保使用的地方能正确获取即可达到混淆的目的

> 从普通字面类型的变量获取 --> 通过函数从对象中获取

常量混淆

- 文字变Unicode编码，js自动支持转换
- 算法加密，读取时通过解密函数还原

运算混淆

- 普通运算表达式变成函数（函数调用，常量均可使用类似的方式处理）


语法丑化

- 在不变化代码功能的情况下，怎么难读怎么处理，例：for ==> do while，do while使用较少，也可增加难度

动态执行

- 普通表达式 ==> 1真1假的两个函数，通过在某个地方设置，让代码始终执行真的函数，if(true) ? （废逻辑插入）

流程混淆


- 顺序扁平化

> 顺序代码 ==> switch case,执行流程不再从上到下

- 条件扁平化

> if else ==> switch case


不透明谓词

- switch case一般时常量，可变成表达式，并且使用变量计算的表达式，将变量（常量）存储在某个地方即可

脚本加壳

- 代码加密 + 参数传递

> aaencode ，是用一些看似表情的符号，声明了一个16位的数组（用来表示16进制位置），然后将code当做字符串遍历，把每个代码符号通过取这个16位的数组下标，拼接成代码。大概的意思就是把代码当做字符串，然后使用这些符号的拼接代替这一段代码

###### 反调试

死循环 + debugger来增加控制台调试难度

- setTimeout定时执行反调试函数
- 代码编译阶段，随机插入反调试函数调用

###### 内容检测

防止通过override的方式将代码保存，修改后执行

- 代码自检：为代码生成hash，然后发现hash不正确则进行处理
- 环境自检：检测URL是否允许使用、当前执行环境，进行数据监控上报/启用木马（node.js环境）等

###### 废代码注入

插入永不执行的代码来混淆

废逻辑插入

增加假代码，并且增加一些逻辑判断，但必定会执行真代码

求值陷阱

类似内容检测，插入正常情况不会执行的代码，特定情况执行时，可

- 数据上报
- 木马/本地记录，长期跟踪
- 释放CSRF漏洞，反追踪
- 开启自杀，（页面崩溃、死循环、大量占用内存）


加壳干扰

在代码用eval包裹，然后对eval参数进行加密，并埋下陷阱，在解码时插入无用代码，干扰显示，大量换行、注释、字符串等大量特殊字符，导致显示卡顿。

### 5

#### C# 

Task.Factory.StartNew，内部如果是async的话，不会等待
1、改成async function，不套Task.Factory.StartNew
2、使用Task.Run

#### Flutter

[布局尺寸](https://mp.weixin.qq.com/s/t5R112IIQUc9SXwWeAgsoA)


### 6

#### C#

##### Async/Await

```C#

async void Bar();// 不可等待，调用后就不管了

async Task Foo(); // 可等待


```
##### 问题

调试时一直说找不到dll且debug模式却用的release的路径
> 重启vs

##### DataTable/DataRow

- 单元格存在readonly导致无法赋值
- 单元格值长度有max限制，会导致无法赋值
- 单元格有Not Null限制，导致无法创建空白Row


创建datarow
```c#

object[] objs = dataRow.itemArray;

dataRow.Table.Rows.Add();

```


### 8

#### spfx

spfx部署时回收站清除

#### SQL

```sql

GO 
create table tb_TestTable400 --创建表 
( 
id int identity(1,1) primary key, 
userName nvarchar(40) not null, 
userName1 nvarchar(40) not null, 
userName2 nvarchar(40) not null, 
userName3 nvarchar(40) not null, 
userName4 nvarchar(40) not null, 
userName5 nvarchar(40) not null, 
userName6 nvarchar(40) not null, 
userName7 nvarchar(40) not null, 
userName8 nvarchar(40) not null, 
userName9 nvarchar(40) not null, 
userName10 nvarchar(40) not null, 
userPWD nvarchar(40) not null, 
userPWD1 nvarchar(40) not null, 
userPWD2 nvarchar(40) not null, 
userPWD3 nvarchar(40) not null, 
userPWD4 nvarchar(40) not null, 
userPWD5 nvarchar(40) not null, 
userPWD6 nvarchar(40) not null, 
userPWD7 nvarchar(40) not null, 
userPWD8 nvarchar(40) not null, 
userPWD9 nvarchar(40) not null, 
userPWD10 nvarchar(40) not null, 
userPWD11 nvarchar(40) not null, 
userPWD12 nvarchar(40) not null, 
userPWD13 nvarchar(40) not null, 
userPWD14 nvarchar(40) not null, 
userEmail nvarchar(40) null 
) 
GO

set identity_insert tb_TestTable400 on 
declare @count int 
set @count=1 
while @count<=500000 
begin 
insert into tb_TestTable400( id , userName, userName1, userName2,userName3, userName4, userName5, userName6, userName7, userName8, userName9, userName10, userPWD, userPWD1,userPWD2, userPWD3, 
userPWD4, userPWD5, userPWD6, userPWD7, userPWD8, userPWD9, userPWD10, userPWD11, userPWD12,userPWD13, userPWD14, userEmail ) values(@count,newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid(),newid()) 
set @count=@count+1 
end 
set identity_insert tb_TestTable400 off

```

#### Git

[5中gitflow介绍](https://zepel.io/blog/5-git-workflows-to-improve-development/)