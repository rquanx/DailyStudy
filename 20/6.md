### 1

#### 包管理

常见包管理测试，当依赖同一个库不同版本时，会根据路径最短...多种方式选定依赖于什么版本的包
> 子库依赖自己的包，不需要管？

##### nuget

包存储在全局上，并且拍平
> 包/版本/内容
> 对于包的依赖，通过描述文件定义，同样拍平到全局存储上

分类
- 普通包
- 元包（不包含DLL和依赖）
    - 描述了一组放在一起有意义的包


### 4

#### 网站优化

1、查看network看文件请求大小
看请求Header是否有content-encoding
一般是gzip, deflate, br
[Directives](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding#Directives)
- gzip 来自UNIX gzip程序的常见的压缩形式，其他命名x-gzip
- compress 来着UNIX压缩程序，由于专利问题，比较少用
- br Brotli algorithm
- identity
- deflate zlib structure的压缩

nodejs启用压缩
```js
const compression = require('compression');
app.use(compression());
```

启用压缩后请求上可以看到压缩前后的大小分别是多少

2、Properly size images

1、换成小图片
2、设置多个大小的图片，浏览器会根据情况选中合适大小的图片
    [教程](https://developers.google.cn/web/fundamentals/design-and-ux/responsive/images#relative_sized_images)
3、使用CDN
4、图片压缩

3、阻塞资源处理/Eliminate render-blocking resources

使用show Coverage查看代码利用率

 Show Request Blocking
 > 打开控制面板，可以block特定路径的文件请求

 4、优化加载内容

 懒加载、异步加载、tree shaking
 
 5、减少主线程使用的时间

使用Performance，实体的块表示主线程？脚本执行？
根据Time块确定哪里占用大量时间，再看在这个时间内其他区块的哪部分是可以优化的，或者看出是由什么导致的

#### C#

变量名可以使用不可见的Unicode空白字符

#### JS

 Monorepo 单仓库多项目的模式

### 5

#### JS

##### Continuation 

CPS

- 每个函数的最后一个参数都是它的 continuation
- 函数内部不能显式地使用 return
- 函数只能通过调用 continuation 以传递它完成的计算结果

callCC（call with current continuation）

- 接受一个函数为唯一参数
- 该函数也有唯一一个参数 cont，代表 callCC 的后续计算
- callCC 会立即调用其函数参数
- 执行过程中，cont 可以接受一个参数作为 callCC 的返回值，一旦调用，则忽略后续所有计算，程序控制流跳转会 callCC 的调用处继续执行

1、可中断程序，并且将中断值作为结果返回
2、可恢复 == 中断中断操作

能够暴露给用户程序从而可以在恰当时机恢复执行

本质：一个高级版本的能够处理函数表达式的 Goto 语句



##### 实现生成器

```js
var next = 0;
while(1) {
    switch(next) {
        case: 0
            // code
            next = 1;
            break;
        case: 1:
            // code
            next = 2;
            break;
        case: 2: 
            return next;
    }
}
// 基于此示例扩展
```

[参考资料])(https://zhuanlan.zhihu.com/p/94611888)

### 7

#### web

##### 视频

```js
var promise = navigator.mediaDevices.getUserMedia(constraints);
```

### 10

#### JS

##### docz

docz可编写md + 代码预览的文档

### 11

#### TS

TypeScript 默认我们数组中的元素是可变的，所以它会「悲观的」推断我们可能会改变元素的顺序

```ts
function swap<T, K>(v1: T, v2: K) {
  return [v2, v1]
}
// 会被推断为 (T | K) []

function swap<T, K>(v1: T, v2: K) {
  return [v2, v1] as const
}
// 固定推断为[K,T]
```

### 12

#### APP

##### 占用率
https://tongji.baidu.com/research/app
https://mta.qq.com/mta/data/device/os

#### 任务管理

任务可追溯：写任务时把大致方案写上
问题追根溯源：处理问题需要追根溯源，从源头上解决，例：数据从由销售系统反馈，如何反馈，明确机制找出问题;
方案追根溯源：设计方案时需要追根溯源，了解使用场景，从而考虑更好的方案，例：需要为x，业务提出要求，基于业务原始需求、应用场景，挖掘更好的方案
测试用例：测试时需要明确指明特殊情况，当任务只能通过特定方式进行测试才能进行时，需注明测试方式和无法测试的场景
协作推进：当任务无法推动时，需抛出问题，让对应的人员知道，然后让能推动的人去推动

#### 面向对象

#### 类Adapter

1、抽象类定义底层基础类的结构和方法
2、继承抽象类，可以实现在相同api限制下，内部有多种实现的不同基础类
3、在基础类上套上一层父级，父级根据实际情况选用不同实现的子类（工厂？）
4、父类关心接口层 API，子类关心基于这套接口 API 如何具体实现


#### Web

##### 按需加载

使用场景：BI平台、工具，普遍是报表形态，关联的筛选条件和联动关系错综复杂，任何一个筛选条件变化就会导致其关联项重新取数并重渲染组件，而报表数据量非常大

目的：保持在大数据场景下BI展示的性能

方案：通过监听Dom可见性从而判断元素是否要进行重新渲染，当不可见时，及时发生外部条件变化，也不进行刷新渲染

核心：IntersectionObserver/setInterval + 元素可见性计算 + 面向对象的类实现


### 13

#### 话术

回到刚才说的xxx，我想再追问一个问题

#### IIS

##### 503错误

503  一般是应用程序池未启动 

##### 请求失败

已设置超时，请求满一定时间时会自动失败，浏览器显示net::err_failed
可能是服务器代理或其他设置了执行超时时间
> iis executimeout


#### 数据库

##### 来源

IBM研究员1974年发表SEQUEL，由于商标原因改为SQL

DBMS:DataBase Management System


NoSQL的定义一直处于变化中

##### 类型

关系型

非关系型：键值型(redis)、文档型(mongodb)、列存储、搜索引擎(ES、Splunk、Solr)、图形

列存储
> 列式数据库，数据展示还是行，但是数据读取是列，可以读取某一列的数据

图形
> 利用了图(数据结构)存储，例子：社交关系

##### 场景

###### 表备份

SELECT * into table_bak FROM table
不需要建表


##### 执行

语法检查：检查 SQL 拼写是否正确，如果不正确
语义检查：检查 SQL 中的访问对象是否存在。
权限检查 -> 缓存 -> 解析器 -> 优化器 -> 执行器

缓存：Oracle通过共享池进行缓存，MySQL新版本中已去除


###### 外键

优点：
1、减少业务与数据耦合
2、保持数据一致性

缺点:
1、产生额外开销
2、无法支持水平拆分、分库
3、高并发时容易出现性能问题

### 14

#### 数据库

Count(*) ≈  count(1) > count(field)

asc升序，desc降序

2级索引

### 16

#### APP

自定义配置存在storage中
数据存储在sqlite中，防止数据库升级导致数据丢失?

#### Web

##### 微前端

目的：用最爽的姿势写最新的业务模块
项目模块开发技术栈无关

##### 多线程

1、单纯使用共享内存，当多个worker运行时，容易竞争
2、为了解决竞争，浏览器提供了Atomics API，可以将操作封装成原子操作，不会被中断（锁）
3、基于Atomics API进行封装锁，从而是实现


### 18

#### 团队代码管理

一、命名规范

类型定义最好加上前缀，区别类型和值(这可以通过 TSlint 约束)
```json
// tslint.json 
{ 
  "rules": { 
    "interface-name": [true, "always-prefix"]
  }
}
```

CSS Class 的命名也是可以使用 stylelint 约束的
```json
// .stylelintrc.json
{
  "rules": {
    // example：aa-bb-cc，aa-bb-width120
    "selector-class-pattern": "^[a-z][a-z0-9]*((-[a-z0-9]+)*|[a-z0-9]*)$"
  }
}
```
二、类型

TS减少any

三、注释

减少无意义的注释，这只猫是猫，要写就详细的写

1、复杂代码
2、为了满足业务的妥协代码
3、兼容性代码

#### 火焰图

- 每一列代表一个调用栈，每一个格子代表一个函数
- 纵轴展示了栈的深度，按照调用关系从下到上排列。最顶上格子代表采样时，正在占用 cpu 的函数。
- 横轴的意义是指：火焰图将采集的多个调用栈信息，通过按字母横向排序的方式将众多信息聚合在一起。需要注意的是它并不代表时间。
- 横轴格子的宽度代表其在采样中出现频率，所以一个格子的宽度越大，说明它是瓶颈原因的可能性就越大。
- 火焰图格子的颜色是随机的暖色调，方便区分各个调用信息。
- 其他的采样方式也可以使用火焰图， on-cpu 火焰图横轴是指 cpu 占用时间，off-cpu 火焰图横轴则代表阻塞时间。


#### SQL

##### 连接

等值连接

```sql
select * from a,b where a.x = b.x
```

非等值连接

```sql
SELECT * FROM a, b WHERE a.x BETWEEN b.x AND b.x
```

外连接

```sql
select * from a join b on a.x = b.x
```

自连接

```sql
select * from a as aa,a as bb where aa.x = x and bb.x < x
```

外连接相比其他连接，外连接是取小表进行hash连接，其他则是先将表进行笛卡尔积再进行过滤，会占用更多资源？



##### 数据库范式及编程规范

根据实际情况取舍

例：

数据库范式
student(id, name)，class(id, description)，student_class(student_id, class_id)
三张表，查询时需要join，会容易产生性能问题

编程规范
student_class_full(student_id, class_id, name, description)
使用一张大表存储所有字段，虽然字段有冗余，但是不需要join


##### Hash连接

用第一个表（小表）建hash table，第二个表在hash table中查找匹配的项，复杂度是n，hash table占的内存可能会比较大


###### 原理

两个表做hash连接，较小的表作为驱动表（这里指运用了过滤条件后结果集较小的表），另一个表称为探测表

在两个表做hash连接的过程中，对驱动表的关联列使用两个内置函数计算hash值，两个hash值分别记为hash_value_1和hash_value_2,hash_value_1相同的记录存放在一个hash bucket中，这里注意hash bucket只需要记录该sql语句的查询列、关联列及hash_value_2即可。hash table由这些hash bucket组成

流程
1、利用连接列上的hash函数，将从驱动表上获取的结果集做成hash table存放在内存中，hash table中单元是hash bucket，key/value，value就是hash bucket
2、取探测表的数据，对每一个数据都做关联列上的hash函数（和驱动表的hash函数相同），定位到hash table中的hash bucket，找到hash bucket就进去看看有没有匹配的数据
3、如果hash bucket里没有数据，则丢弃探测表中的这一行数据。如果有，则进一步查看里面的数据是否和探测表的这条记录匹配
4、循环处理，直到处理完探测表中的所有记录，返回结果集

##### nested loop join 嵌套连接

两个表读一行数据进行两两对比，复杂度是n^2

##### block nested loop join

从两个表读很多行数据，然后进行两两对比，复杂度也是n^2

##### index nested loop join

从第一个表读一行，然后在第二个表的索引中查找这个数据，索引是B+树索引，复杂度可以近似认为是nlogn

##### 索引

Where和Order尽量使用索引，where可以避免全表扫描，order可以避免FileSort排序

MySQL中排序有两种
- Index排序：索引可以保证数据的有序性，因此不需要再进行排序。
- FileSort排序：一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/O到磁盘进行排序，效率较低。

###### 索引失效

- 函数处理
- <>
- !=
- NULL

##### 命名

Linux 的环境下
MySQL 数据库名、表名、变量名是严格区分大小写的，而字段名是忽略大小写

Windows 的环境下
MySQL 全部不区分大小写

##### 子查询

关联/非关联 == 先有鸡还是先有蛋

###### 关联子查询

必须先执行外层查询，接着对所有通过过滤条件的记录，执行内层查询。外层查询和内层查询相互依赖，因为外层查询会把数据传递给内层查询

###### 非关联子查询

必须先完成内层查询之后，外层查询才能介入 ==> 外部查询返回的每一行数据，内部查询都要执行一次


##### 使用

###### IN/EXISTS

in是把外表和内表作hash 连接，而exists 是对外表作loop 循环，每次loop 循环再对内表进行查询

一般IN/EXISTS都能得到相同的结果，建立索引的情况下，看外部查询的主表的大小
外部查询主表 > 内部查询子表 ==> IN效率高，对内部查询子表进行了索引
外部查询主表 < 内部查询子表 ==> EXISTS效率高，对外部查询主表进行了索引

外表大，用IN；内表大，用EXISTS

###### not in/not exists

not in 那么内外表都进行全表扫描，没有用到索引,not extsts 的子查询依然能用到表上的索引,not exists > not in



### 19

#### SQL

##### 视图

1、SQL的聚合
2、屏蔽底层复杂SQL
3、聚合需要的数据进行展示
4、安全，视图操作不会影响底层数据表

1、视图隐藏了底层的表结构，简化了数据访问操作，客户端不再需要知道底层表的结构及其之间的关系。

2、视图提供了一个统一访问数据的接口。（即可以允许用户通过视图访问数据的安全机制，而不授予用户直接访问底层表的权限），从而加强了安全性，使用户只能看到视图所显示的数据。
3、视图还可以被嵌套，一个视图中可以嵌套另一个视图

PS：视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。

###### 应用

购物车临时视图

###### 视图索引

视图是虚拟表，它只是封装了底层的数据表查询接口，因此有些 RDBMS 不支持对视图创建索引（有些 RDBMS 则支持，比如新版本的 SQL Server）

#### 存储过程

SQL 语句的封装,SQL的函数

优点
1、一次编译多次使用
2、模块化

缺点
1、可移植性差
2、调试困难，只有少数数据库支持调试
3、开发、维护困难
4、不适合高并发

#### 事务

ACID

原子性（Atomicity）：原子的概念就是不可分割，进行数据处理操作的基本单位
一致性（Consistency）：数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。
隔离性（Isolation）：它指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。一个事务在提交之前，对其他事务都是不可见的。
持久性（Durability）：事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。因为当事务完成，数据库的日志就会被更新，这时可以通过日志，让系统恢复到最后一次成功的更新状态。

##### 事务异常

脏读（Dirty Read）：读取到了未提交的事务产生的数据
不可重复读（Nnrepeatable Read）：一个事务内根据同一个条件对行记录进行多次查询，读取的结果不同，数据变化
幻读（Phantom Read）：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读，数量变化

###### 隔离级别

读未提交（READ UNCOMMITTED ）：全部允许，不会使用锁
读已提交（READ COMMITTED）：允许不可重复读，常见的默认隔离级别（Oracle 和 SQL Server）
可重复读（REPEATABLE READ）：允许幻读，MySQL 默认的隔离级别
可串行化（SERIALIZABLE）:避免所有异常，将事务进行串行化，也就是在一个队列中按照顺序执行，牺牲了系统的并发性

隔离级别越低，意味着系统吞吐量（并发程度）越大，出现异常问题的可能性会更大


### 20

#### SQL

##### 分布式事务

在分布式系统分库情况下，由于涉及多库操作，传统事务难以满足需求


###### 串行事务方案 + 补偿事务

多库事务按顺序执行，事务1-->事务2-->事务3,从事务1提交后，到事务3结束间均可能产生异常且可异常时间长

对每个事务增加补偿事务,即反向操作，当事务失败时，执行反向事务操作
> 补偿事务通用性差
> 需要增加大量业务判断，执行特定补偿事务
> 补偿事务失败

吞吐量大，事务执行完立即释放

###### 后置提交优化方案

多个事务先执行，后提交，事务1执行 --> 事务2执行 --> 事务3执行 --> 事务1提交 --> 事务2提交 --> 事务3提交

将可异常时间缩短至事务2、3的提交，大大减少可异常时间，减少异常可能性
可在后置提交优化基础上适当加入补偿事务？

所有事务执行完毕才释放，吞吐量小

#### 领导能力

第一阶段：熟悉自己的业务，知道问题在哪里，怎样可以解决。

领导者是给大家指方向的，你必须先知道要走哪个方向，才能带领别人，这是领导力的基础。

第二阶段：培养说服能力，能说服他人，问题可以按照你说的方式解决。

领导力的表现是，他人愿意服从你。这不能都靠制度压服，而要让他人真心觉得你是对的。如果你可以让他人相信你，你就可以领导。

第三阶段：激发他人的热情，让他们产生解决问题的热情。

说服他人的更高境界，是让他们真正投身进来，自觉发挥自己的潜力，全力以赴解决需要解决的问题。好的领导和差的领导，区别就在于能否激励下级，让每个人都知道自己的职责，努力工作。

第四阶段：你培养其他人的领导能力。

如果你离开，团队也能正常运作下去，说明一切已经制度化了，你的领导已经成功了。这时，你可以让其他人接管团队，自己去实现下一个目标。

#### Git

##### Tag使用

###### 版本号
```v<major>.<minor>.<patch>```


- major: breaking changes
- minor: version compatible with previous version
- patch: bug fix

```bash
git tag
# 列出所有的tag

git tag -l "1.0*"
# 筛选tag


git show <tag_name>
# Eg. git show v1.0.1
# 显示tag详情

git tag -d <tag_name>
# 删除tag

git fetch --tags
# 拉起tags

git tag <tag_name>
# Eg. git tag v1.0.1

git tag -a <tag_name> -m "message"
# Eg. git tag -a v1.0.1 -m "First release"

git checkout <tag_name>
# Eg. git checkout v1.0.1
# 代码回滚至特定tag版本

git tag <tag_name> <commit_sha>
# 以特定commit打tag

git push --tags
# 推送tag至远程服务器


```


### 21

#### JSPerf

arr1 x 596,505 ops/sec ±1.14% (95 runs sampled)
> ops/sec  每秒执行的次数，越高越好
> ±1.14%    统计误差,相比最好的慢了多少

#### 性能优化

##### LCP

Largest Contentful Paint

衡量标准报告视口内可见的最大内容元素的渲染时间。为了提供良好的用户体验，网站应努力在开始加载页面的前 2.5 秒内进行 最大内容渲染


#### 代码

##### 命名

有意义的区分
```
bad

product、productInfo、productData
zork、theZork
Customer、CustomerObject
money、moneyAmount
accountData、account
```

##### 语境不明的变量

在函数中存在几个变量，且变量间可能不存在太多关联关系，在函数过程中不断的if/else，改变变量的值，导致难以抽离
可以将变量抽离成类，通过类的属性和方法进行管理

##### 不添加多余的语境

由于处于xxx项目，所以全部添加XXX作为前缀

##### 函数

###### 函数抽象层级

函数应该根据抽象层级进行拆分，不同抽象层级的代码不应该写在一起
1、要做a、b
2、要做a则需要完成c、d
3、要做c则需要完成e、f、g

层级划分

##### 注释

###### 废话的日志注释

有代码管理工具后不需要

###### 注释的代码

有代码管理工具后不需要

###### 重复的废话

例如api文档提示每个字段都要设置注释


#### js

##### 形参

形参和实参有没了解
如果实参传的值比形参多会怎样，为什么

##### 重载
重载有没了解
为什么js没有重载
函数是对象，是一个引用;函数名实际上指向函数对象的指针

一般类型语言：是通过方法签名来唯一确定一个方法。所谓方法签名包括：方法名、参数类型和参数顺序、参数个数这几个要素
JavaScript：函数(或对象方法)完全靠函数名称唯一确定，JS不将参数列表作为区分函数的依据。函数是作为一种特殊对象类型存在的，函数的名字只是一个普通的变量

##### arguments

函数形参和arguments是别名方式，修改形参数据或arguments数据均会互相影响

##### 异常捕获

try-catch 
只能捕获捉到运行时非异步错误，对于语法错误和异步错误就捕捉不到。
> 语法错误，由于是编译阶段，非运行阶段，即使在catch内也无法捕获

window.onerror 
能捕获所有运行时错误，无法捕获语法错、Promise异常和网络异常的错误
> 网络异常错误：如img.src获取图片
> 网络异常错误不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等

unhandledrejection
Promise 全局异常捕获事件 


###### 异常上报

img标签上报
```js
function report(error) {
  var reportUrl = 'http://xxxx/report';
  new Image().src = reportUrl + 'error=' + error;
}
```