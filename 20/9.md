### 1

#### C#

##### Attribute

AuthorizeAttribute,MVC提供的特性，可以用来进行校验
handleErrorattribute

abstract 方法会要求子类重写


##### 扩展方法
1、在静态类中定义
2、第一个参数必须写this
3、不能与调用方在同一个类中

### 6

#### SQL

sql server json_value只能不能用于text类型字段，可用于nvarchar

### 7

#### JS

##### 元编程

对比C#元编程

根据字符串实例化对象: eval
根据字符串读取方法调用: obj[method]()
根据字符串读取属性: obj[field]


#### C#

##### 反射

###### Assembly

- Load  当前路径下加载dll
- LoadFrom   当前路径下加载dll
- LoadFile   指定特定路径下加载Dll

###### Type

###### Method

**Getmethod**  

根据方法名获取方法，可通过传入type参数来查找方法重载

静态方法：同样可通过getmethod读取调用

```C#
instance.Getmethod("Name",new Type[] { typeof(int) });
```

bindingflags：通过配置bindingflags参数可以强行读取私有方法

**泛型方法**

getmethod后通过makegenericmethod，设置好泛型，然后进行调用

###### Class

**泛型类**

makrgenerictype后再进行实例化


###### Field

获取字段对象：Getfields

静态字段和普通字段一样读取


###### Prop

获取属性对象：Getproperties

设置属性值：setvalue

读取属性值：getvalue

静态属性和普通属性一样读取

##### 类型转换

As进行类型转换，失败时会返回null (强制转换会异常)

```C#
var type = typeof(string);

var t1 = (int)Activator.CreateInstance(type);   // t1异常
var t2 = Activator.CreateInstance(type) as int; // t2为null
```

### 8

#### DNS

DNS污染
> ping github.io 是127.0.0.1

#### C#

##### 静态构造函数

没有参数、没有修饰符、自动在合适的时候被调用，可以被用来初始化静态变量

##### 泛型约束

where T:class：类型参数必须是引用类型，包括任何类、接口、委托或数组类型

where T:struct：类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型

where T:new()：无参数构造函数约束，当与其他约束一起使用时，new() 约束必须最后指定

##### 分层

抽象层作为单独项目被双方依赖

1、抽象
不同层之间通过接口进行解耦，高层不再依赖于特定底层实现，而依赖于特定接口(抽象)
- JS由于类型问题，天生支持接口抽象

2、工厂模式
问题：层级之间通过抽象进行关联后，最终到实际操作时仍基于抽象实例化出特定的对象
解决：通过工厂模式，将对象构造交给第三方进行处理，主要代码里即可脱离特定对象的实例化

3、反射 + 配置文件

问题：单纯的工厂模式，虽然主体中解耦了，但第三方工厂仍基于抽象实例化出特定的对象
解决：通过反射 + 配置文件，动态加载Dll，然后进行实例化，即可完全脱离


##### 依赖注入

IOC容器：本质是一个工厂

###### 形式

构造函数注入
属性注入
方法注入

###### 场景

简化对象创建
生命周期管理
对象工厂解耦

###### 简易IOC容器

1、私有类型映射缓存：Dictionary<string,Type> / Dictionary<Type,Type>? 
> string是fullName,能用Type来替代？
2、注册方法：像映射缓存中存储映射
3、对象创建GetService
> 基础：直接创建对象，默认使用无参数构造函数
> 追加参数构造函数：读取构造函数并且取参数最多的进行执行，读取构造函数的参数类型，对参数类型进行GetService实例化并使用参数进行创建对象
> 追加多重依赖处理：应对当构造函数参数又依赖于其他对象情况，调整为对参数进行递归GetService
> 追加属性注入：在实例创建后，遍历属性，对容器注册的属性进行实例化赋值注入
> 追加方法注入：方法会通过特定方式标识，通过标识识别方法？看autofac实际使用方式，模拟实现
> 生命周期：