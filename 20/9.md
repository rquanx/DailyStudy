### 1

#### C#

##### Attribute

AuthorizeAttribute,MVC提供的特性，可以用来进行校验
handleErrorattribute

abstract 方法会要求子类重写


##### 扩展方法
1、在静态类中定义
2、第一个参数必须写this
3、不能与调用方在同一个类中

### 6

#### SQL

sql server json_value只能不能用于text类型字段，可用于nvarchar

### 7

#### JS

##### 元编程

对比C#元编程

根据字符串实例化对象: eval
根据字符串读取方法调用: obj[method]()
根据字符串读取属性: obj[field]


#### C#

##### 反射

###### Assembly

- Load  当前路径下加载dll
- LoadFrom   当前路径下加载dll
- LoadFile   指定特定路径下加载Dll

###### Type

###### Method

**Getmethod**  

根据方法名获取方法，可通过传入type参数来查找方法重载

静态方法：同样可通过getmethod读取调用

```C#
instance.Getmethod("Name",new Type[] { typeof(int) });
```

bindingflags：通过配置bindingflags参数可以强行读取私有方法

**泛型方法**

getmethod后通过makegenericmethod，设置好泛型，然后进行调用

###### Class

**泛型类**

makrgenerictype后再进行实例化


###### Field

获取字段对象：Getfields

静态字段和普通字段一样读取


###### Prop

获取属性对象：Getproperties

设置属性值：setvalue

读取属性值：getvalue

静态属性和普通属性一样读取

##### 类型转换

As进行类型转换，失败时会返回null (强制转换会异常)

```C#
var type = typeof(string);

var t1 = (int)Activator.CreateInstance(type);   // t1异常
var t2 = Activator.CreateInstance(type) as int; // t2为null
```

### 8

#### DNS

DNS污染
> ping github.io 是127.0.0.1

#### C#

##### 静态构造函数

没有参数、没有修饰符、自动在合适的时候被调用，可以被用来初始化静态变量

##### 泛型

###### 约束

where T:class：类型参数必须是引用类型，包括任何类、接口、委托或数组类型

where T:struct：类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型

where T:new()：无参数构造函数约束，当与其他约束一起使用时，new() 约束必须最后指定

###### 缓存

泛型是在运行时根据类型创建不同的类，并且缓存起来，性能较好
> 可通过编译将泛型提前编译？

##### 分层

抽象层作为单独项目被双方依赖

1、抽象
不同层之间通过接口进行解耦，高层不再依赖于特定底层实现，而依赖于特定接口(抽象)
- JS由于类型问题，天生支持接口抽象

2、工厂模式
问题：层级之间通过抽象进行关联后，最终到实际操作时仍基于抽象实例化出特定的对象
解决：通过工厂模式，将对象构造交给第三方进行处理，主要代码里即可脱离特定对象的实例化

3、反射 + 配置文件

问题：单纯的工厂模式，虽然主体中解耦了，但第三方工厂仍基于抽象实例化出特定的对象
解决：通过反射 + 配置文件，动态加载Dll，然后进行实例化，即可完全脱离


##### 依赖注入

IOC容器：本质是一个工厂

###### 形式

构造函数注入
属性注入
方法注入

###### 场景

简化对象创建
生命周期管理
对象工厂解耦

###### 简易IOC容器

1、私有类型映射缓存：Dictionary<string,Type> / Dictionary<Type,Type>? 
> string是fullName,能用Type来替代？
> 为了实现其他附加功能，适当调整Dictionary
2、注册方法：像映射缓存中存储映射，类型约束，映射之间应存在泛型约束
3、对象创建GetService
> 基础：直接创建对象，默认使用无参数构造函数

> 追加参数构造函数：
1、取参数最多
读取构造函数并且取参数最多的进行执行，读取构造函数的参数类型，对参数类型进行GetService实例化并使用参数进行创建对象
2、取超集
取参数包含全部的，如果有不包含的报错
3、指定特定构造函数
提供额外信息，利用Attribute进行标记构造函数，处理时优先取有标记的

> 追加多重依赖处理：应对当构造函数参数又依赖于其他对象情况，调整为对参数进行递归GetService
> 追加属性注入：
1、全量属性注入
在实例创建后，遍历属性，对容器注册的属性进行实例化赋值注入
2、特定属性注入
提供额外信息，利用Attribute进行标记属性

> 追加方法注入：
1、全量方法出入
在实例创建后，遍历方法参数，对容器注册的属性进行实例化赋值注入？
2、特定方法注入
提供额外信息，利用Attribute进行标记属性，然后对方法参数进行注入?
3、调用注入（常规做法）
依据标记构造后调用特定方法，并且根据方法参数注入参数

> 接口一对多
增加参数进行标识，如Name
1、修改/添加字典以支持
2、存放时使用fullName + Name

> 常量注入，构造函数存在基础类型，如int
增加常量字典，注册时声明参数，固定int等类型参数的，处理时先根据key取常量，在构造参数时根据类型从常量中获取

> 生命周期：
对象重用管理
1、瞬时
每次都是新的
2、单例
全局单例
3、Scope
请求过程中单例,利用了框架引擎的机制，

应用：DBContext

1、Asp.NetCore
每个请求创建子容器（Clone容器）
将固定的映射复制，实例另外通过字典缓存，每次都建立一个空的缓存字段

4、线程单例
1、CallContext
旧框架才有，AsyncLocal检查线程内是否存在

2、



5、外部可释放单例

### 11

#### 跨域

Access-Control-Allow-Credentials：可选，
true: 表示允许发送cookie，此时Access-Control-Allow-Origin不能设置为*，必须指定明确的，与请求网页一致的域名。
不设置该字段：不需要浏览器发送cookie

withCredentials 前端设置发送Cookie

#### source map

##### 配置

source-map、eval、inline、cheap、module的组合

- eval: 代码使用eval包裹，生成sourceURL映射压缩前的代码路径,生成的映射会作为DataURI嵌入,不单独生成.map文件
- source-map: 生成source map文件
- inline: .map文件内容作为DataURI嵌入,不单独生成.map文件
- cheap: 没有生成列映射(column mapping)，只是映射行数
- module: 应对打包工具将代码转换后再进行混淆时丢失定位，jsx --> js --> min，无法定位到jsx的具体位置

##### TS

###### infer

推断类型：自动将参数提取出来进行使用
extends的条件语句中推断待推断的类型

使用场景:
React推断reducer返回值
对于联合类型进行推断

```ts
type ReturnType<T> =  T extends (...args: any[]) => infer P ? P :any;

type Func = () => User;
type Test = ReturnType<Func> // Test == User

// infer 将返回值提取成P,并在后续的返回值中使用
```


```ts

type Ids = number[];
type Names = string[];

//  获取数组里的元素类型
type Unpacked<T> = T extends Names ? string : T extends Ids ? number : T;

type idType = Unpacked<Ids>; // idType 类型为 number
type nameType = Unpacked<Names>; // nameType 类型为string

// 使用infer
type Unpacked<T> = T extends (infer R)[] ? R : T;

type idType = Unpacked<Ids>; // idType 类型为 number
type nameType = Unpacked<Names>; // nameType 类型为string

```




##### 模板字符串

```ts
// 配合infer

type Whitespace = ' ' | '\n' | '\r' | '\t'  // 空格类型

type TrimStart<S extends string, P extends string = Whitespace> =
  S extends `${P}${infer R}` ? TrimStart<R, P> : S
TrimStart<'---value','-'> // ==> value

// ---value 是否继承于`${P}${infer R}` ==> ${P} == -, ${infer R} == --value
// 是继承，infer提取出R即--value,再进行TrimStart<R, P>
// 递归进行去除-

```

#### JS

##### 插件系统

1、对象存储插件，通过插件名来作为key
2、指定插件的执行函数
3、执行时，对特定插件或全部插件执行插件的执行函数，并且把设计的值传入

> 生命周期
> loader?

### 12

#### Life

如果总要等到一切都准备好了再去做，那永远都可以找到没准备好的理由，这样的话究竟要等多久


### 14

#### C#


##### 参数传入数组

构造函数、方法调用时List参数传入
> 利用反射调用


##### 指定参数

```C#
a.(para2: xxxx); // 给para2指定参数，不影响其他参数
```

##### 构造函数内存分配

在调用构造函数前已经分配好对象，可以使用this，构造函数进行初始化

### 15

#### C#


webapi默认是拒绝option请求的需要删除掉OPTIONSVerbHandler

#### AOP

单层AOP及多层嵌套AOP

多层AOP --> 洋葱模型

### 16

#### 人

当成员不回复时需要注意了