## 8
### 信息
如今信息太多，对于重要的信息要进行审视

#### 判断
如果一条信息对你来说很重要，重要到你想把它转发到朋友圈、分享给朋友，那么，不妨先后退一步，审视一下：
文章里面有哪些事实？有无来源？是否可靠？是否有立场？

### 工具
#### 虚拟机

##### 黑苹果
黑苹果连接iphone没反应，use服务启动，设置为兼容usb2.0

### 生存

#### 小技巧
吃很撑的时候可以嚼颗口香糖，欺骗胃进行蠕动消化

#### 必需品
对于必需品，当出现可能的灾难时要提前备好（2020年肺炎，口罩）

### 个人

#### 自省
沟通能力，一说话就容易急！

#### 思想

不要患得患失，要想能得到什么，不要总想失去什么

思考问题时联系知识点、看过的书

不要感谢苦难，而是感谢勇于吃苦的自己

#### 理论
代价和珍惜程度
> 付出代价越多越珍惜
例：
> 用爱发电，难以持续
> 收费后形成契约，从而对人产生约束，从而坚持下来

恐惧更容易引起人的注意，所以经常被利用在各个领域
> 营销？


### 能力
#### 写作
1、以说代写
一开始不知道如何下手，可以通过口述将说的话变成文字（科大讯飞，语音转文字）

2、对象感
对于不同的人，书写的内容是不一样的，想象文档是写给哪些人看的

3、问问题
以问问题为脉络进行内容填充
	为什么用这个技术，没用之前遇到什么问题，痛点是什么
	这个技术能帮助解决什么问题
	引入新技术后产生了什么新问题
	对于新的问题是什么类型的问题，如何解决的
	在这个过程收获了什么，有什么感悟
> 即使有问题仍然回答不出东西：知识积累太少，需要汲取更多的知识

x、扩展
《风格的感觉》中会提及写作的技巧


#### 阅读
阅读书籍是与伟人们对话的过程，也是理解他们如何认识世界、改造世界的过程

### 工作

#### 招聘

##### 有工作经验
对人进行画像构建

1、技术
有技术追求的人一般会做过以下的事
- 框架搭建、类库编写
- 算法、计算机原理


2、项目
客户分类
企业、政府类项目一般技术较弱
做非完全外包、面对知名私企、外企，对客能力，一般技术好点

项目类型分类
电商、CRM：一般中大型
小程序：一般小型

规模分类
中型：15~20
大型：50以上

###### 参考画像
综合型选手

性别：男
年龄：27-32
形象：干净整洁，短发，喜欢穿着POLO衫、休闲裤和运动鞋
性格：开朗外向
沟通：语言表达良好，善于结合过往经验进行形象化的描述
兴趣：电影/各类球赛、关心时事
技能：项目管理、需求分析、软件开发
经验：1-3年开发，2年以上项目管理，有中大型定制开发类项目经验，接触客户多为知名私企
专业：计算机类大专
语言：普通话标准

经验型/理论型选手

性别：男
年龄：30-35
形象：干净整洁，戴眼镜，梳油头，喜欢穿着衬衣、西裤和皮鞋
性格：严肃冷静
沟通：语言表达良好，善于结合理论知识进行专业化的说明，善于总结
兴趣：财经、管理学、方法论
技能：项目管理、需求分析
经验：4年以上项目管理，有BPM/CRM/ERP类项目经验，接触客户多为知名外企
专业：理工类专业
语言：普通话标准、能够进行英文邮件交流

技术型选手

性别：男
形象：干净整洁，戴眼镜，喜欢穿单色T恤、牛仔裤和运动鞋
年龄：27-32
性格：内向单纯
兴趣：技术、科学、动漫/游戏
沟通：书面表达优于语言表达，逻辑清晰
技能：需求分析、系统设计、软件开发
经验：1-3年开发，2年以上技术/开发管理，外包类项目为主，较少对客类项目经验
专业：计算机类本科
语言：普通话基本标准、粤语流利




#### 面试

##### 简历
1、通过简短的说明描述清楚自己的情况
2年开发经验
擅长前端
前端技术组长，技术Leader
技术栈

2、曾经做过的项目、遇到的技术难题，需要理解面试官想要什么
做过最自豪的项目,最难的技术问题或技术含量高的
> 考察做过最高级的东西，兴趣点、兴奋点	

做过最痛苦、最艰难的项目
> 解决难题的能力和面对难题的态度

犯过的技术错误	
> 看面对错误的自省....,容易有坑

3、回答问题技巧
学会利用STAR原则
S	在什么样的环境和条件下
T	要做什么
A	付出什么样的努力，做了什么行动
R	取得什么样的结果

重点：体现出自己的骄傲、顽强、家人，思考、沉淀、总结、成长


#### 工作层次划分
劳工：凭速度和数量，完成重复的劳动
技工：在完成劳工的事时，会使用新的，先进的工具，但无法解决问题
特种工：了解技术原理，解决问题，处理底层问题的人
设计、架构：复用、维护、稳定
经理：把控进度、组织团队，宣扬文化，把握方向，应用场景


#### 判断公司好坏
小公司看人、看融资（查融资）


#### 创业
创业公司由于资源有限要瞄准一个点努力，不要一开始就想做平台
> 关联到个人，先专精一个方向，再拓展开？

小公司要战胜大公司
1、必须要有颠覆性的创新技术，洋枪洋炮对大刀长枪
2、能借力于时代的其他技术进步的帮助（大公司由于历史包袱无法借用）

#### 产品
需求：这个需求是要做什么，为了什么

好的产品必须要有足够的时间和人员进行打磨

#### 沟通
- 对于任务，要理解好，不需要上级、同事反复的说
- 汇报的时候重点在结果，不用说太多过程，在基于推进进度的角度汇报

#### 有效工作
1、做什么事情对公司最有帮助
2、从提升公司效益、提升自身能力的角度来评判任务重要性


#### 杂
- 要看中机会，不要看是否离家近等无关的东西


新东西的出现历程
- 第一眼美女：横空出世，问题多
- 第二眼美女：可以使用，但昂贵，  初代iphone
- 第三眼美女：好用、集成化、平民化

对于技术是否成熟可看是否在黄赌毒中使用上


### 问题
请求完成，但缺少内容
> js缺少内容

### 单元测试

#### why
85%的缺陷都在代码设计阶段产生，而发现bug的阶段越靠后，耗费成本就越高，指数级别的增高


保持unit test代码的稳定，主要靠好的API设计。
> API切实正确切割了需求，那么在重构的时候API就基本不用变化，unit test也不用重写。

重构的时候，只要unit test覆盖的够好，可以节省大量的时间。

#### 分类
- 小型测试：针对单个函数的测试，关注其内部逻辑，mock所有需要的服务。
    > 小型测试带来优秀的代码质量、良好的异常处理、
优雅的错误报告
- 中型测试：验证两个或多个制定的模块应用之间的交互
- 大型测试：也被称为“系统测试”或“端到端测试”。大型测试在一个较高层次上运行，验证系统作为一个整体是如何工作的。


#### effect
- bug类指标（间接指标）：连续迭代的bug总数趋势、迭代内新建bug的趋势、千行bug率
- 单测的需求覆盖度（50%以上），参与人员覆盖度（80%以上）单测case总数趋势，代码行增量趋势
- 增量代码的行覆盖率（接入层80%，客户端30%）
- 单函数圈复杂度（低于40），单函数代码行数（低于80），扫描告警数

#### how
参考pnpjs


### 代码

#### 原则

##### 开闭原则
对拓展开发，对修改闭合，在加新功能时尽量不对原有代码进行修改，而是在基础上进行扩展，所以代码要写成便于扩展

接口对于开闭原则的意义
> 抽象好稳定的接口，通过接口限制来保证架构稳定

#### 规范
husky

#### Api规范
路径
> /系统/模块/操作	
> 分离pc、app、…

Header
可以附带客户端、版本号、请求网络、token等

请求
json加密

参数
字段空值时，不传递字段

### 后端
#### 数据库
##### 刷数据
Update a set a.c1 = b.c2 from a,b where a.ID = b.ID
> 将a表的c1字段值更新为b表的c2值

##### 主键
UUID/GUID 作为主键
优点：
	在所有分片数据中都是唯一，容易跨数据库迁移合并
	插入数据库前就知道主键值
	相比数字主键更不容易泄漏信息
缺点：
	不直观
	不能用于聚集索引，排序效率低，sql server的newsequentialid()
	开销大
[UUID相关文章和讨论](https://tomharrisonjr.com/uuid-or-guid-as-primary-keys-be-careful-7b2aa3dcb439)



#### C#
vs打开项目后全部报错，提示找不多类，可能是项目配置改了，记录：ServiceMe.Apps.CRM.Core.csproj


### Flutter
路由动画
> 继承PageRouteBuilder，重写transitionsBuilder方法
> 已封装好的动画效果，xxxTransition

RepaintBoundary
> 渲染一块区域，可通过自带UI库，将对应取回进行截图
> 作为一个单独区域渲染时，利用好可以减少渲染性能消耗

涂鸦功能实现
1、Canvas作为画笔
2、RepaintBoundary 截图widget

### Web

#### JS
xhr.open ie11 url为空字符串会抛异常


#### 浏览器
[dom加载事件](https://javascript.info/onload-ondomcontentloaded)

#### React
useRef
> 可当作this，作为一个固定的容器存放想要保持的数据




### 学习

#### how
1、有整体的学习计划，然后拆分下来，再慢慢消化

2、不要羞于提问
反思：很多时候希阳哥会问这个怎么实现的，但是在面对css问题时，却说不出来

3、知识要有积累，复用，不要零散，进行关联


建立：愿景--目标--道路

从不中听的话中找到合理性，对于事情需要反思三遍
- 换位思考，是否自己做错了？错在哪里？
- 假设对方是对的，是否自己错了？错在哪里？
- 有没可能是由于自己眼界、境界问题，无法理解到对方？


#### 技巧
学习的时候要对细节进行抽象，太复杂的东西很难一次掌握。先掌握核心

#### 技术
学习:技术是什么，为什么，解决了什么问题
> 技术主要作用：降低门槛

##### 主流技术
主流技术的形成需要满足：
- 大公司背书
- 杀手级应用
- 强大的社区

##### 进阶
语言层面：编程范式、设计模式、代码设计
原理层面：操作系统、网络、数据库、计算机
理论：算法、架构、分布式




### 15

#### 数据库
null 和 空字符串
为什么数据库使用is null 来判断null
> 在数据库中null标识unkonw值，所以不一样
> 除了oracle，oracle是将空字符串和null都当中空值，会自动将空字符串转化为Null


#### git

##### 命令
git cat-file -t [hash]
> 查看objects存储的数据类型

git cat-file -p [hash]
> 查看objects中存储的内容

git tag -a
> 添加附注，创建tag

##### git object类型
blob
> 存储文件内容
> 不记录文件名，当文件名发生变化时，由于内容不变可复用object,只需新增tree
> 新增或修改文件内容时生成

tree
> 存储目类结构，目录快照
> 记录了目类中每个文件的权限、objects类型、hash名(SHA1值)、普通文件名
> tree只存储当前层次的目录信息，然后通过子tree来完整记录整棵树
> 文件 -> blob
> 文件夹 -> tree

commit
> 记录commit信息
> 提交时生成

tag 
> 附注

##### git如何存储文件
对每个文件生成git objects，存储到.git/objects中


##### 提交文件变动时会做什么
1、对变动的文件生成新的blob objects
2、生成新的目类快照tree objects
3、生成新的commit objects
4、新commit指针指向前一个commit
5、分支header指针指向新的commit

head -> master -> new commit -> pre commit -> old tree
							 -> new tree -> sub blob
							 			 -> sub tree

##### git objects的好处
提交、目类、内容分别拆成objects,当发生变化时，只需将指针从旧objects指向新的objects即可，没有发生的objects可以全部复用

##### 为什么tree和object分离
复用，分离后文件名修改或目类结构发生变化，但文件内容不变时，只需生产新的tree即可，blob可以复用，大部分时候tree是更轻量的

##### 为何每次文件变化均生成完整新的object
性能、使用取舍

如果只存储变化的内容，当想要获取到完整的内容时，则需要从第一个commit一直计算到最新的commit才能得到

##### 每次生成新的object是否会造成空间占用

Git会有垃圾回收机制gc，不仅会清除无用的object，还会把已有的相似object打包压缩,生成一个pack和index文件

##### 历史记录篡改问题
SHA1哈希算法和哈希树，参考区块链
当某个节点的哈希发生变化时，后面所有的节点哈希都要修改

假设你偷偷修改了历史变更记录上一个文件的内容，那么这个文件的blob object的SHA1哈希值就变了，与之相关的tree object的SHA1也需要改变，commit的SHA1也要变，这个commit之后的所有commit SHA1值也要跟着改变。又由于Git是分布式系统，即所有人都有一份完整历史的Git仓库，所以所有人都能很轻松的发现存在问题。

### 16

#### js
##### Canvas
###### getContext
contextType
- 2d：创建 CanvasRenderingContext2D 二维渲染上下文，像图片这种二维空间的选这个类型。
- webgl/experimental-webgl：创建 WebGLRenderingContext 三维渲染上下文对象，适用于三维动画制作开发。
- webgl2/experimental-webgl2：创建一个 WebGL2RenderingContext 三维渲染上下文对象，webgl的升级版本。
- bitmaprenderer：将创建将canvas内容替换为指定ImageBitmap功能的ImageBitmapRenderingContext，canvas与位图的生成。

###### drawImage
只在contextType为2d的时候才可以被调用

参数可设置位置、大小.....

可进行画图、组合图、剪切图、放大镜

###### toDataURL
将画板生成data URL
> data:[<mediatype>][;base64],<data>

有参数可设置质量

##### 应用
###### 图片合成
使用canvas
1、将一张图片作为背景，画出
2、在画好的基础上画上第二张图片
3、保存
注意：两张图片需要注意大小、先后关系

场景：水印...


##### 浮点数精度
js使用IEEE754 标准(IEEE 二进制浮点数算术标准)表示整数和浮点数

##### 存储
浮点数存储（科学计数法）
> Value = sign * exponent * fraction

以0.1 的二进制 0.00011001100110011…… 
> 表示为：1 * 2^-4 * 1.1001100110011……
> sign = 1   exponent = 2^-4 fraction = 1.1001100110011……

##### 二进制科学计数
当只进行二进制数存储时可简化表达式为：V = (-1)^S * (1 + Fraction) * 2^E
> S 用来标记正负
> 1 + Fraction 按科学计数法和二进制，必为1.xxxx，所以fraction可以留出1，然后只存储后面的数据，减少占用
> E 幂次,E可以为负

##### 移码
由于E可以是负数，为了解决存储问题，对E进行位移（加一定的值）从而只存储正数，在计算时再减回去
> 例:使用8bit存储时，大小为-127~127，所以存储E + bias，在8bit时，bias = 127 = 2^7 - 1 == 2^(bit - 1) - 1

##### 标准
在IEEE754 标准中
- 正负:1bit
- 幂次:11bit
- Fraction:52bit

> 0.1表示完整表示则是0 01111111011 1001100110011001100110011001100110011001100110011010
> S = 0, E = -4 + 2^(11 - 1) - 1 = 1019
> 由于0.1是无限循环，所以在存储0.1的时候已存在精度丢失

##### 运算
二进制运算
对阶：两个数变成幂次相等的形式
尾数运算：普通加减
规格化：转化为科学计数形式
舍入处理：规格化后，结果位数超过精度，则最后一位会被舍去，且根据四舍五入，0舍1入
溢出判断：...

以0.1 + 0.2为例，存储时精度丢失 + 运算时舍入精度丢失导致 0.1 + 0.2 != 0.3


### 17

#### React
##### setstate
###### 同步/异步
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。

###### 异步
setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。

###### 批量更新
setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。

###### 验证
简短的页面，两个按钮，一个使用原生事件进行setState，一个使用合成事件setState


#### Flutter
Spuernova 
> 根据设计稿生成flutter代码
> 部分可直接复制使用

#### css
##### 定位

###### 普通流
浏览器默认的 HTML 布局方式，此时浏览器不对页面做任何布局控制，
position为static或relative，且float为none时会触发普通流，普通流有以下特性：

- 普通流中，所有的盒一个接一个排列
- BFC 中，盒子会竖着排列
- IFC 中，盒子会横着排列
- 静态定位中（position 为 static），盒的位置就是普通流里布局的位置
- 相对定位中（position 为 relative），盒的偏移位置由 top，right，bottom，left 定义，即使有偏移，仍然保留原有的位置，其它普通流不能占用这个位置
> 会霸占元素位置 + 偏移位置的空间？待验证

###### 浮动
- 浮动定位中，盒称为浮动盒（Floating Box）
- 浮动盒会脱离普通流，浮动到当前行的开头或结尾
- 普通流会环绕在浮动盒周围，除非设置 clear 属性

##### BFC

###### 产生
以下元素会创建 BFC：
- 根元素（<html>）
- 浮动元素（float 不为 none）
- 绝对定位元素（position 为 absolute 或 fixed）
- 表格的标题和单元格（display 为 table-caption，table-cell）
- 匿名表格单元格元素（display 为 table 或 inline-table）
- 行内块元素（display 为 inline-block）
- overflow 的值不为 visible 的元素
- 弹性元素（display 为 flex 或 inline-flex 的元素的直接子元素）
- 网格元素（display 为 grid 或 inline-grid 的元素的直接子元素）

###### 特点
BFC中间是隔离的：一个元素不能同时存在于两个 BFC 中，当BFC嵌套的时候,内层元素只属于内层BFC
盒子竖着排列：普通流排列
bfc和相邻的元素不产生上下边距折叠
> 使用bfc包裹子元素后，bfc内容子元素不会和bfc的相邻元素产生边距折叠
> 不是bfc会产生折叠
浮动时：不可重叠
计算高度时不会忽略浮动元素的高度，可用来解决高度塌陷

###### 应用
自适应多栏布局
> bfc和相邻的元素不产生上下边距折叠 + 浮动时：不可重叠



##### FFC
flex布局产生
在css2.1中也属于BFC

##### GFC
grid布局产生
在css2.1中也属于BFC


##### :active数据上报
通过伪类来上传按钮点击数据
```css
.button-1:active::after {
    content: url(./pixel.gif?action=click&id=button1);
    display: none;
}
.button-2:active::after {
    content: url(./pixel.gif?action=click&id=button2);
    display: none;
}
```


##### :empty
匹配内容为空的标签

可实现对空内容的标签进行填充/隐藏处理

##### :only-child
匹配没有任何兄弟元素的元素



#### web

##### target="_blank"
当对a标签设置了target="_blank"时会产生的问题

```html
<a href="http://kaysonli.com/" target="_blank">1024译站</a>
```

###### 安全
打开的新窗口可以通过window.opener读取并修改原窗口的信息，即使跨域被限制访问部分属性，仍会有一定的隐患

###### 性能
通过target="_blank"打开的新窗口，会跟原来的页面窗口共用一个进程（看实际浏览器实现），阻塞会影响原页面




