## 8
### 信息
如今信息太多，对于重要的信息要进行审视

#### 判断
如果一条信息对你来说很重要，重要到你想把它转发到朋友圈、分享给朋友，那么，不妨先后退一步，审视一下：
文章里面有哪些事实？有无来源？是否可靠？是否有立场？

### 工具
#### 虚拟机

##### 黑苹果
黑苹果连接iphone没反应，use服务启动，设置为兼容usb2.0

### 生存

#### 小技巧
吃很撑的时候可以嚼颗口香糖，欺骗胃进行蠕动消化

#### 必需品
对于必需品，当出现可能的灾难时要提前备好（2020年肺炎，口罩）

### 个人

#### 自省
沟通能力，一说话就容易急！

#### 思想

不要患得患失，要想能得到什么，不要总想失去什么

思考问题时联系知识点、看过的书

不要感谢苦难，而是感谢勇于吃苦的自己

#### 理论
代价和珍惜程度
> 付出代价越多越珍惜
例：
> 用爱发电，难以持续
> 收费后形成契约，从而对人产生约束，从而坚持下来

恐惧更容易引起人的注意，所以经常被利用在各个领域
> 营销？


### 能力
#### 写作
1、以说代写
一开始不知道如何下手，可以通过口述将说的话变成文字（科大讯飞，语音转文字）

2、对象感
对于不同的人，书写的内容是不一样的，想象文档是写给哪些人看的

3、问问题
以问问题为脉络进行内容填充
	为什么用这个技术，没用之前遇到什么问题，痛点是什么
	这个技术能帮助解决什么问题
	引入新技术后产生了什么新问题
	对于新的问题是什么类型的问题，如何解决的
	在这个过程收获了什么，有什么感悟
> 即使有问题仍然回答不出东西：知识积累太少，需要汲取更多的知识

x、扩展
《风格的感觉》中会提及写作的技巧


#### 阅读
阅读书籍是与伟人们对话的过程，也是理解他们如何认识世界、改造世界的过程

### 工作

#### 招聘

##### 有工作经验
对人进行画像构建

1、技术
有技术追求的人一般会做过以下的事
- 框架搭建、类库编写
- 算法、计算机原理


2、项目
客户分类
企业、政府类项目一般技术较弱
做非完全外包、面对知名私企、外企，对客能力，一般技术好点

项目类型分类
电商、CRM：一般中大型
小程序：一般小型

规模分类
中型：15~20
大型：50以上

###### 参考画像
综合型选手

性别：男
年龄：27-32
形象：干净整洁，短发，喜欢穿着POLO衫、休闲裤和运动鞋
性格：开朗外向
沟通：语言表达良好，善于结合过往经验进行形象化的描述
兴趣：电影/各类球赛、关心时事
技能：项目管理、需求分析、软件开发
经验：1-3年开发，2年以上项目管理，有中大型定制开发类项目经验，接触客户多为知名私企
专业：计算机类大专
语言：普通话标准

经验型/理论型选手

性别：男
年龄：30-35
形象：干净整洁，戴眼镜，梳油头，喜欢穿着衬衣、西裤和皮鞋
性格：严肃冷静
沟通：语言表达良好，善于结合理论知识进行专业化的说明，善于总结
兴趣：财经、管理学、方法论
技能：项目管理、需求分析
经验：4年以上项目管理，有BPM/CRM/ERP类项目经验，接触客户多为知名外企
专业：理工类专业
语言：普通话标准、能够进行英文邮件交流

技术型选手

性别：男
形象：干净整洁，戴眼镜，喜欢穿单色T恤、牛仔裤和运动鞋
年龄：27-32
性格：内向单纯
兴趣：技术、科学、动漫/游戏
沟通：书面表达优于语言表达，逻辑清晰
技能：需求分析、系统设计、软件开发
经验：1-3年开发，2年以上技术/开发管理，外包类项目为主，较少对客类项目经验
专业：计算机类本科
语言：普通话基本标准、粤语流利




#### 面试

##### 简历
1、通过简短的说明描述清楚自己的情况
2年开发经验
擅长前端
前端技术组长，技术Leader
技术栈

2、曾经做过的项目、遇到的技术难题，需要理解面试官想要什么
做过最自豪的项目,最难的技术问题或技术含量高的
> 考察做过最高级的东西，兴趣点、兴奋点	

做过最痛苦、最艰难的项目
> 解决难题的能力和面对难题的态度

犯过的技术错误	
> 看面对错误的自省....,容易有坑

3、回答问题技巧
学会利用STAR原则
S	在什么样的环境和条件下
T	要做什么
A	付出什么样的努力，做了什么行动
R	取得什么样的结果

重点：体现出自己的骄傲、顽强、家人，思考、沉淀、总结、成长


#### 工作层次划分
劳工：凭速度和数量，完成重复的劳动
技工：在完成劳工的事时，会使用新的，先进的工具，但无法解决问题
特种工：了解技术原理，解决问题，处理底层问题的人
设计、架构：复用、维护、稳定
经理：把控进度、组织团队，宣扬文化，把握方向，应用场景


#### 判断公司好坏
小公司看人、看融资（查融资）


#### 创业
创业公司由于资源有限要瞄准一个点努力，不要一开始就想做平台
> 关联到个人，先专精一个方向，再拓展开？

小公司要战胜大公司
1、必须要有颠覆性的创新技术，洋枪洋炮对大刀长枪
2、能借力于时代的其他技术进步的帮助（大公司由于历史包袱无法借用）

#### 产品
需求：这个需求是要做什么，为了什么

好的产品必须要有足够的时间和人员进行打磨

#### 沟通
- 对于任务，要理解好，不需要上级、同事反复的说
- 汇报的时候重点在结果，不用说太多过程，在基于推进进度的角度汇报

#### 有效工作
1、做什么事情对公司最有帮助
2、从提升公司效益、提升自身能力的角度来评判任务重要性


#### 杂
- 要看中机会，不要看是否离家近等无关的东西


新东西的出现历程
- 第一眼美女：横空出世，问题多
- 第二眼美女：可以使用，但昂贵，  初代iphone
- 第三眼美女：好用、集成化、平民化

对于技术是否成熟可看是否在黄赌毒中使用上


### 问题
请求完成，但缺少内容
> js缺少内容

### 单元测试

#### why
85%的缺陷都在代码设计阶段产生，而发现bug的阶段越靠后，耗费成本就越高，指数级别的增高


保持unit test代码的稳定，主要靠好的API设计。
> API切实正确切割了需求，那么在重构的时候API就基本不用变化，unit test也不用重写。

重构的时候，只要unit test覆盖的够好，可以节省大量的时间。

#### 分类
- 小型测试：针对单个函数的测试，关注其内部逻辑，mock所有需要的服务。
    > 小型测试带来优秀的代码质量、良好的异常处理、
优雅的错误报告
- 中型测试：验证两个或多个制定的模块应用之间的交互
- 大型测试：也被称为“系统测试”或“端到端测试”。大型测试在一个较高层次上运行，验证系统作为一个整体是如何工作的。


#### effect
- bug类指标（间接指标）：连续迭代的bug总数趋势、迭代内新建bug的趋势、千行bug率
- 单测的需求覆盖度（50%以上），参与人员覆盖度（80%以上）单测case总数趋势，代码行增量趋势
- 增量代码的行覆盖率（接入层80%，客户端30%）
- 单函数圈复杂度（低于40），单函数代码行数（低于80），扫描告警数

#### how
参考pnpjs


### 代码

#### 原则

##### 开闭原则
对拓展开发，对修改闭合，在加新功能时尽量不对原有代码进行修改，而是在基础上进行扩展，所以代码要写成便于扩展

接口对于开闭原则的意义
> 抽象好稳定的接口，通过接口限制来保证架构稳定

#### 规范
husky

#### Api规范
路径
> /系统/模块/操作	
> 分离pc、app、…

Header
可以附带客户端、版本号、请求网络、token等

请求
json加密

参数
字段空值时，不传递字段

### 后端
#### 数据库
##### 刷数据
Update a set a.c1 = b.c2 from a,b where a.ID = b.ID
> 将a表的c1字段值更新为b表的c2值

##### 主键
UUID/GUID 作为主键
优点：
	在所有分片数据中都是唯一，容易跨数据库迁移合并
	插入数据库前就知道主键值
	相比数字主键更不容易泄漏信息
缺点：
	不直观
	不能用于聚集索引，排序效率低，sql server的newsequentialid()
	开销大
[UUID相关文章和讨论](https://tomharrisonjr.com/uuid-or-guid-as-primary-keys-be-careful-7b2aa3dcb439)



#### C#
vs打开项目后全部报错，提示找不多类，可能是项目配置改了，记录：ServiceMe.Apps.CRM.Core.csproj


### Flutter
路由动画
> 继承PageRouteBuilder，重写transitionsBuilder方法
> 已封装好的动画效果，xxxTransition

RepaintBoundary
> 渲染一块区域，可通过自带UI库，将对应取回进行截图
> 作为一个单独区域渲染时，利用好可以减少渲染性能消耗

涂鸦功能实现
1、Canvas作为画笔
2、RepaintBoundary 截图widget

### Web

#### JS
xhr.open ie11 url为空字符串会抛异常


#### 浏览器
[dom加载事件](https://javascript.info/onload-ondomcontentloaded)

#### React
useRef
> 可当作this，作为一个固定的容器存放想要保持的数据




### 学习

#### how
1、有整体的学习计划，然后拆分下来，再慢慢消化

2、不要羞于提问
反思：很多时候希阳哥会问这个怎么实现的，但是在面对css问题时，却说不出来

3、知识要有积累，复用，不要零散，进行关联


建立：愿景--目标--道路

从不中听的话中找到合理性，对于事情需要反思三遍
- 换位思考，是否自己做错了？错在哪里？
- 假设对方是对的，是否自己错了？错在哪里？
- 有没可能是由于自己眼界、境界问题，无法理解到对方？


#### 技巧
学习的时候要对细节进行抽象，太复杂的东西很难一次掌握。先掌握核心

#### 技术
学习:技术是什么，为什么，解决了什么问题
> 技术主要作用：降低门槛

##### 主流技术
主流技术的形成需要满足：
- 大公司背书
- 杀手级应用
- 强大的社区

##### 进阶
语言层面：编程范式、设计模式、代码设计
原理层面：操作系统、网络、数据库、计算机
理论：算法、架构、分布式




## 15

#### 数据库
null 和 空字符串
为什么数据库使用is null 来判断null
> 在数据库中null标识unkonw值，所以不一样
> 除了oracle，oracle是将空字符串和null都当中空值，会自动将空字符串转化为Null


#### git

##### 命令
git cat-file -t [hash]
> 查看objects存储的数据类型

git cat-file -p [hash]
> 查看objects中存储的内容

git tag -a
> 添加附注，创建tag

##### git object类型
blob
> 存储文件内容
> 不记录文件名，当文件名发生变化时，由于内容不变可复用object,只需新增tree
> 新增或修改文件内容时生成

tree
> 存储目类结构，目录快照
> 记录了目类中每个文件的权限、objects类型、hash名(SHA1值)、普通文件名
> tree只存储当前层次的目录信息，然后通过子tree来完整记录整棵树
> 文件 -> blob
> 文件夹 -> tree

commit
> 记录commit信息
> 提交时生成

tag 
> 附注

##### git如何存储文件
对每个文件生成git objects，存储到.git/objects中


##### 提交文件变动时会做什么
1、对变动的文件生成新的blob objects
2、生成新的目类快照tree objects
3、生成新的commit objects
4、新commit指针指向前一个commit
5、分支header指针指向新的commit

head -> master -> new commit -> pre commit -> old tree
							 -> new tree -> sub blob
							 			 -> sub tree

##### git objects的好处
提交、目类、内容分别拆成objects,当发生变化时，只需将指针从旧objects指向新的objects即可，没有发生的objects可以全部复用

##### 为什么tree和object分离
复用，分离后文件名修改或目类结构发生变化，但文件内容不变时，只需生产新的tree即可，blob可以复用，大部分时候tree是更轻量的

##### 为何每次文件变化均生成完整新的object
性能、使用取舍

如果只存储变化的内容，当想要获取到完整的内容时，则需要从第一个commit一直计算到最新的commit才能得到

##### 每次生成新的object是否会造成空间占用

Git会有垃圾回收机制gc，不仅会清除无用的object，还会把已有的相似object打包压缩,生成一个pack和index文件

##### 历史记录篡改问题
SHA1哈希算法和哈希树，参考区块链
当某个节点的哈希发生变化时，后面所有的节点哈希都要修改

假设你偷偷修改了历史变更记录上一个文件的内容，那么这个文件的blob object的SHA1哈希值就变了，与之相关的tree object的SHA1也需要改变，commit的SHA1也要变，这个commit之后的所有commit SHA1值也要跟着改变。又由于Git是分布式系统，即所有人都有一份完整历史的Git仓库，所以所有人都能很轻松的发现存在问题。

## 16

#### js
##### Canvas
###### getContext
contextType
- 2d：创建 CanvasRenderingContext2D 二维渲染上下文，像图片这种二维空间的选这个类型。
- webgl/experimental-webgl：创建 WebGLRenderingContext 三维渲染上下文对象，适用于三维动画制作开发。
- webgl2/experimental-webgl2：创建一个 WebGL2RenderingContext 三维渲染上下文对象，webgl的升级版本。
- bitmaprenderer：将创建将canvas内容替换为指定ImageBitmap功能的ImageBitmapRenderingContext，canvas与位图的生成。

###### drawImage
只在contextType为2d的时候才可以被调用

参数可设置位置、大小.....

可进行画图、组合图、剪切图、放大镜

###### toDataURL
将画板生成data URL
> data:[<mediatype>][;base64],<data>

有参数可设置质量

##### 应用
###### 图片合成
使用canvas
1、将一张图片作为背景，画出
2、在画好的基础上画上第二张图片
3、保存
注意：两张图片需要注意大小、先后关系

场景：水印...


##### 浮点数精度
js使用IEEE754 标准(IEEE 二进制浮点数算术标准)表示整数和浮点数

##### 存储
浮点数存储（科学计数法）
> Value = sign * exponent * fraction

以0.1 的二进制 0.00011001100110011…… 
> 表示为：1 * 2^-4 * 1.1001100110011……
> sign = 1   exponent = 2^-4 fraction = 1.1001100110011……

##### 二进制科学计数
当只进行二进制数存储时可简化表达式为：V = (-1)^S * (1 + Fraction) * 2^E
> S 用来标记正负
> 1 + Fraction 按科学计数法和二进制，必为1.xxxx，所以fraction可以留出1，然后只存储后面的数据，减少占用
> E 幂次,E可以为负

##### 移码
由于E可以是负数，为了解决存储问题，对E进行位移（加一定的值）从而只存储正数，在计算时再减回去
> 例:使用8bit存储时，大小为-127~127，所以存储E + bias，在8bit时，bias = 127 = 2^7 - 1 == 2^(bit - 1) - 1

##### 标准
在IEEE754 标准中
- 正负:1bit
- 幂次:11bit
- Fraction:52bit

> 0.1表示完整表示则是0 01111111011 1001100110011001100110011001100110011001100110011010
> S = 0, E = -4 + 2^(11 - 1) - 1 = 1019
> 由于0.1是无限循环，所以在存储0.1的时候已存在精度丢失

##### 运算
二进制运算
对阶：两个数变成幂次相等的形式
尾数运算：普通加减
规格化：转化为科学计数形式
舍入处理：规格化后，结果位数超过精度，则最后一位会被舍去，且根据四舍五入，0舍1入
溢出判断：...

以0.1 + 0.2为例，存储时精度丢失 + 运算时舍入精度丢失导致 0.1 + 0.2 != 0.3


## 17

#### React
##### setstate
###### 同步/异步
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。

###### 异步
setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。

###### 批量更新
setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。

###### 验证
简短的页面，两个按钮，一个使用原生事件进行setState，一个使用合成事件setState


#### Flutter
Spuernova 
> 根据设计稿生成flutter代码
> 部分可直接复制使用

#### css
##### 定位

###### 普通流
浏览器默认的 HTML 布局方式，此时浏览器不对页面做任何布局控制，
position为static或relative，且float为none时会触发普通流，普通流有以下特性：

- 普通流中，所有的盒一个接一个排列
- BFC 中，盒子会竖着排列
- IFC 中，盒子会横着排列
- 静态定位中（position 为 static），盒的位置就是普通流里布局的位置
- 相对定位中（position 为 relative），盒的偏移位置由 top，right，bottom，left 定义，即使有偏移，仍然保留原有的位置，其它普通流不能占用这个位置
> 会霸占元素位置 + 偏移位置的空间？待验证

###### 浮动
- 浮动定位中，盒称为浮动盒（Floating Box）
- 浮动盒会脱离普通流，浮动到当前行的开头或结尾
- 普通流会环绕在浮动盒周围，除非设置 clear 属性

##### BFC

###### 产生

以下元素会创建 BFC：

- 根元素（<html>）
- 浮动元素（float 不为 none）
- 绝对定位元素（position 为 absolute 或 fixed）
- 表格的标题和单元格（display 为 table-caption，table-cell）
- 匿名表格单元格元素（display 为 table 或 inline-table）
- 行内块元素（display 为 inline-block）
- overflow 的值不为 visible 的元素
- 弹性元素（display 为 flex 或 inline-flex 的元素的直接子元素）
- 网格元素（display 为 grid 或 inline-grid 的元素的直接子元素）

###### 特点

BFC之间是隔离的：一个元素不能同时存在于两个 BFC 中，当BFC嵌套的时候,内层元素只属于内层BFC
盒子竖着排列：普通流排列
bfc和相邻的元素不产生上下边距折叠
> 使用bfc包裹子元素后，bfc内容子元素不会和bfc的相邻元素产生边距折叠
> 不是bfc会产生折叠
浮动时：不可重叠
计算高度时不会忽略浮动元素的高度，可用来解决高度塌陷

###### 应用

自适应多栏布局
> bfc和相邻的元素不产生上下边距折叠 + 浮动时：不可重叠

##### FFC

flex布局产生
在css2.1中也属于BFC

##### GFC

grid布局产生
在css2.1中也属于BFC


##### :active数据上报
通过伪类来上传按钮点击数据
```css
.button-1:active::after {
    content: url(./pixel.gif?action=click&id=button1);
    display: none;
}
.button-2:active::after {
    content: url(./pixel.gif?action=click&id=button2);
    display: none;
}
```


##### :empty
匹配内容为空的标签

可实现对空内容的标签进行填充/隐藏处理

##### :only-child
匹配没有任何兄弟元素的元素



#### web``

##### target="_blank"
当对a标签设置了target="_blank"时会产生的问题

```html
<a href="http://kaysonli.com/" target="_blank">1024译站</a>
```

###### 安全
打开的新窗口可以通过window.opener读取并修改原窗口的信息，即使跨域被限制访问部分属性，仍会有一定的隐患

###### 性能
通过target="_blank"打开的新窗口，会跟原来的页面窗口共用一个进程（看实际浏览器实现），阻塞会影响原页面

## 18

#### APP

[唤起 App](https://mp.weixin.qq.com/s/OW7JugyOZJwokWSXnixKsQ)


#### 工程化

[node从零搭建自动化部署管理平台](https://mp.weixin.qq.com/s/UVcZh0QE8g52Iv5UB_61tQ)

#### 数据库

查询瓶颈：数据结构、磁盘读取（从磁盘读取 1B 数据和 1KB 数据所消耗的时间是基本一样）

##### 索引

较频繁的作为查询条件的字段应该创建索引；
唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件；
更新非常频繁的字段不适合创建索引

##### 索引数据结构

哈希表
> 优点：可快速查找特定的数据,时间复杂度O(1)
> 风险：可能存在哈希碰撞，但即使碰撞，仍能快速定位
> 缺点：无法高效进行范围查找

二叉树
> 优点：虽然单点查找是比哈希表慢，但由于树的关系，可以让左侧树为小于，右侧树为大于，可快速进行范围查询，相当于二分查找，时间复杂度O(logn)
> 缺点：二叉树可能会不平衡，极端情况下树可能退变为链表，导致效率大幅降低，复杂度降低为O(N)


红黑树
会自动调整树形态的树结构
> 优点：当二叉树处于不平衡的状态时可自行调整，来保持基本平衡，时间复杂度O(logn)
> 缺点：当数据按顺序插入时，会产生右倾，虽然没退变成链表，但效率仍然大幅度下降

AVL树
绝对平衡的二叉树
> 优点：不错的查找性能（O（logn）），不存在极端的低效查找的情况；可以实现范围查找、数据排序
> 缺点：当使用AVL树后会发现，查询瓶颈在磁盘读取中，虽然时间复杂度合适了，但是由于磁盘瓶颈仍不适用

B树
每个节点限制最多存储两个 key，一个节点如果超过两个 key 就会自动分裂，节点中存储数据
> 优点：一个节点存储多个数据，一次读取磁盘获取到更多的数据，降低瓶颈影响，B 树的查找性能等于 O（h*logn），其中 h 为树高，n 为每个节点关键词的个数

B+树
mysql底层使用的数据结构，节点中存储索引（地址）
> 优点：相比于B树的存储数据，存储索引能存储更多的数据


##### 聚集/非聚集索引
索引和数据是分开不同文件存储还是存储在一起

###### 非聚集
索引文件更小，查询性能更好

###### 聚集
相对非聚集，会冗余更多的数据在文件中

## 19

#### 设计模式

##### 工厂模式

###### 简单工厂

接口定义产品，有n个产品，但只有一个工厂
> 使用：工厂内实现根据传入的类型返回对应的产品,少量产品时使用
> 新增：需要定义新产品，然后修改工厂，工厂容易臃肿
> 改善：可以通过反射来改善简单工厂
> 通过反射 + 配置文件，即可替代工厂模式

###### 工厂模式

接口定义产品和工厂，有n个产品和n个工厂，各自实现自己的产品和工厂
> 使用：传入类型Class?根据反射可以创建对应的工厂，然后产出对应的产品，大量产品扩展时使用
> 新增：只需实现自己的产品和工厂，不需要反复修改旧有的工厂
> 工厂模式和抽象工厂模式区别，对工厂进行了抽象

###### 抽象工厂

一个工厂对应n个的产品，每个产品有n种系列，然后有多少系列就有多少个工厂
> 一个工厂需要定义n个产品，新增产品时需要修改所有工厂？


## 22

#### git

commit --amend修改最近的一次提交


#### .net core

环境检查
> Dotnet –info

##### 问题

Error 500.19
> 部署站点还需要安装Hosting Bundle

#### 正则

\b 单词边界

#### webpack

require的时候对应相同路径但不同后缀的文件可能会查找错误，例：require("xxx") 想要找xxx.js但找了xxx.css，
> 解决：需要在webpack中设置resolve的顺序

## 23

#### 项目

系统设计：需求确认、原型设计、架构设计....
开发：设计、编码、测试
交付：部署、文档

#### 自省

在别人说话的时候不要急着插嘴、打断

#### 求职

##### 简历

针对不同的投递企业，针对性的突出不同的亮点，而不是同一份简历海投
亮点尽量写在前面

忌：
- 简历太花
- 尽写空话
- 工作经历写了好几页
- 错别字

##### 面试

常见准备:
- 自我介绍
- 公司了解
- 为什么离职
- 你有什么要问我的吗

自我介绍
> 在介绍中就包含动机和引导面试官的提问方向

项目经验阐述：包含目的、成果、贡献
> crm主推使用Flutter，完全没有技术积累，原生开发不现实，Cordova、RN、Flutter
> 可能使用RN会好一点,背靠js生态，技术较熟，遇到问题也能更容易处理，其他同事更容易参与
> 忽略了项目紧急程度和低估了Flutter上手成本，Flutter的成熟度

回答问题时不追求快
回答问题时进行扩展、引导、互动

遇到不了解的问题时
> 对这个问题中的XX概念我不太了解，如果你可以帮我稍作讲解，我可以尝试回答一下这个问题

优缺点
> 不说空话:有上进心啊、学习能力强啊什么的
> 利用具体事例说明
> 从缺点反推优点
> 要符合企业文化

提问题，要务虚？
- 贵公司最让你自豪的企业文化是什么？
- 团队/公司现在面临的最大挑战是什么？
- 未来加入团队，你对我的期望是什么？
- 我入职后的工作范围是什么，工作内容有哪些？

谈薪资
> 从行业报告或大公司分级中寻找参照

职业规划
> 不说职务而是方向、成就

觉得之前回答不好需要弥补
> 刚才那个问题我现在想想好像回答的不太对。我平时有复盘的习惯，遇到这种情况我会去查阅更多的资料去求证，不会草率决定。不过目前没有这样的条件，所以可能回答的不好

##### 面试官

能不能胜任？
意愿强不强？
来了之后能不能稳定？

##### 公司了解

公司的发展历史，建立多久了？发展情况如何？规模如何？

公司的业务情况，公司的主营业务是什么？最近有什么新动态，是不是考虑做其他业务？

公司在行业内的地位与口碑，同行的竞争对手是谁？公司在业内排名如何？

融资情况

##### 峰终定律

如果在一段体验的高峰和结尾，体验是愉悦的，那么对整个体验的感受就是愉悦的。
> 把握好开头、高峰和结尾，更容易被记住、产生好感

#### web

##### Puppeteer

Node库，提供了一组用来操纵 Chrome 的 API，默认 Headless 也就是无界面的chrome，俗称“无头浏览器”

###### 应用

[骨架屏自动生成](https://mp.weixin.qq.com/s/4DAlmuMzyNjDKvaoOU1GoA)



##### 移动端
user-scalable 设置为 no 可以解决移动端点击事件延迟问题


## 25

#### Web性能

##### 参考指标

1、页面初载时，所有未压缩的 JavaScript 脚本大小：<=200KB；
2、页面初载时，所有未压缩的 CSS 资源大小：<=100KB；
3、HTTP 协议下，请求资源数：<=6 个；
4、HTTP/2 协议下，请求资源数：<=20 个 ；
5、90%的代码利用率（也就是说，仅允许 10% 的未使用代码）；
> 代码利用率 = 你页面中实际被执行的代码 / 你页面中引入的代码 * 100%
> chrome 开发工具 Cmd + Shift + P or Ctrl + Shift + P  --> 输入Coverage可以查看使用率工具


#### 代码分割
```js
// 静态分割固定路径?
const getModal = () => import('./src/modal.js') 

// 动态加载
const getTheme = (themeName) => import(`./src/themes/${themeName}`)
// 实现
// Webpack 会在构建时将你声明的目录下的所有可能分离的代码都抽象为一个文件（这被称为 contextModule 模块）

```

#### webpack魔术注释
```js
import (
  /* webpackChunkName: “my-chunk-name” */ 	// 设置chunk name
  /* webpackMode: lazy */					// 设置懒加载模式
  /* webpackPrefetch: true */				// 类似<link rel=“prefetch”> 在空闲时加载所需资源，确保代码在未来一定会用到时，再开启该
  './footer'
)
```

#### 编码
##### 职责链
每个 else if 分支都包含了复杂的条件判断，且其对执行的先后顺序有所要求
```js
const rules = [
  {
    match: function (a, b, c) { /* ... */ },
    action: function (a, b, c) { /* ... */ }
  },
  {
    match: function (a, b, c) { /* ... */ },
    action: function (a, b, c) { /* ... */ }
  },
  {
    match: function (a, b, c) { /* ... */ },
    action: function (a, b, c) { /* ... */ }
  }
  // ...
]

// 按顺序进行匹配并且执行
function demo (a, b, c) {
  for (let i = 0; i < rules.length; i++) {
    if (rules[i].match(a, b, c)) {
      return rules[i].action(a, b, c)
    }
  }
}

```

## 29

#### 其他

让正确的事持续发生

#### js

##### 一元运算符

为什么 + 'b' === Nan
> [看规范](https://tc39.es/ecma262/#sec-unary-plus-operator)


#### C#

[system.badimageformatexception 未能加载文件或程序集问题解决](https://blog.csdn.net/weixin_33881753/article/details/85745198)
> 原因是项目CPU默认X86我的系统是X64，将目标平台改为 Any CPU就可以了;

#### Flutter

##### 项目创建

flutter create --org com.caojianfeng abc
> 快速这是应用组织和名称    最终appid会是com.caojianfeng.abc
> 对应
> AndroidManifest.xml中的package字段
> ios/prooject.pbxproj中的PRODUCT_BUNDLE_IDENTIFIER字段

##### 应用显示名

android/app/src/main/AndroidManifest.xml  android:label
ios/Runner/Info.plist   <key>CFBundleName</key> <string>应用名</string>

##### boundary to img

```dart
  // 手动导入一下iamge包
  import 'package:image/image.dart' as image;
  
  // 将一个Widget转为image.Image对象
  Future<image.Image> _getImageFromWidget() async {
    // _globalKey为需要图像化的widget的key
    RenderRepaintBoundary boundary = _globalKey.currentContext.findRenderObject();
    
    // ui.Image => image.Image
    var img = await boundary.toImage();
    var byteData = await img.toByteData(format: ImageByteFormat.png);
    var pngBytes = byteData.buffer.asUint8List();

    return image.decodeImage(pngBytes);
  }

```

## 31

#### html

邮件可以写html，且设置style

##### table

cellpadding
> 表格内容padding

cellspacing

border
> 表格边框宽度



#### MSSQL

##### 存储过程执行
exec name

##### 角色
| 角色名称          | 功能描述                                                     |
| ----------------- | ------------------------------------------------------------ |
| **bulkadmin**     | 可以运行 bulk insert 语句  bulk insert 详细 http://blog.csdn.net/jackmacro/article/details/5959321 |
| **dbcreator**     | 创建，修改，删除，还原任何数据库                             |
| **diskadmin**     | 管理磁盘文件                                                 |
| **processadmin**  | 可以终止在数据库引擎实例中运行的程序                         |
| **securityadmin** | 可以管理登录名及其属性，具有grant,deny,和revoke服务器和数据库级别权限，还可以重置sql server 登录名的密码 |
| **serveradmin**   | 可以更改服务器范围的配置选项和关闭服务器                     |
| **setupadmin**    | 可以添加和删除链接服务器，并对可以执行某些系统执行存储过程(如，sp_serveroption) |
| **sysadmin**      | 在sql server中进行任何活动，该觉得的权限跨越所有其他固定服务器角色，默认情况下，windows builtin\admin组(本地管理员组)的所有成员都是sysadmin 固定服务器角色的成员 |



##### 权限

deny权限优先级更高，例：设置了owner和denywriter，仍然是不可写的



| 角色名称              | 功能描述                                                     |
| --------------------- | ------------------------------------------------------------ |
| **db_owner**          | 可以执行数据库中技术所有动作的用户                           |
| **db_accessadmin**    | 可以添加，删除用户的用户                                     |
| **db_datareader**     | 可以查看所有数据库中用户表内数据的用户                       |
| **db_datawrite**      | 可以添加，修改，删除所有数据库用户表内数据的用户             |
| **db_ddladmin**       | 可以在数据库中执行ddl操作的用户，DDL（Data Definition Language）数据表的创建以及管理 |
| **db_securityadmin**  | 可以管理数据库中与安全权限有关所有动作的用户                 |
| **db_backoperator**   | 可以备份数据库的用户(可以发布dbcc和checkPoint语句，这两个语句一般在备份前使用 |
| **db_denydatareader** | 不能看到数据库中任何数据的用户                               |
| **db_denydatawrite**  | 不能修改数据库中任何数据的用户                               |

